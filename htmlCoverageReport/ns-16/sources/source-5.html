


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MethodGraph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.scaffold</a>
</div>

<h1>Coverage Summary for Class: MethodGraph (net.bytebuddy.dynamic.scaffold)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">MethodGraph$Compiler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (8/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (36/42)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer$ForJavaMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer$ForJavaMethod$Token</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Detached</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Harmonized</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (22/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60.3%
  </span>
  <span class="absValue">
    (38/63)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Ambiguous</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/55)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Initial</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (4/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39.4%
  </span>
  <span class="absValue">
    (13/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Resolved$Node</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Graph</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger$Directional</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$ForDeclaredMethods</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Empty</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (2/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked$Delegation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Sort</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Simple</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (3/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    62.8%
  </span>
  <span class="absValue">
    (76/121)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.8%
  </span>
  <span class="absValue">
    (203/364)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;
&nbsp;  // IntelliJ API Decompiler stub source generated from a class file
&nbsp;  // Implementation of methods is not available
&nbsp;
&nbsp;package net.bytebuddy.dynamic.scaffold;
&nbsp;
&nbsp;public interface MethodGraph {
&nbsp;    net.bytebuddy.dynamic.scaffold.MethodGraph.Node locate(net.bytebuddy.description.method.MethodDescription.SignatureToken signatureToken);
&nbsp;
&nbsp;    net.bytebuddy.dynamic.scaffold.MethodGraph.NodeList listNodes();
&nbsp;
&nbsp;    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;    static class Simple implements net.bytebuddy.dynamic.scaffold.MethodGraph {
&nbsp;        private final java.util.LinkedHashMap&lt;net.bytebuddy.description.method.MethodDescription.SignatureToken,net.bytebuddy.dynamic.scaffold.MethodGraph.Node&gt; nodes;
&nbsp;
&nbsp;        public Simple(java.util.LinkedHashMap&lt;net.bytebuddy.description.method.MethodDescription.SignatureToken,net.bytebuddy.dynamic.scaffold.MethodGraph.Node&gt; nodes) { /* compiled code */ }
&nbsp;
&nbsp;        public static net.bytebuddy.dynamic.scaffold.MethodGraph of(java.util.List&lt;? extends net.bytebuddy.description.method.MethodDescription&gt; methodDescriptions) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.Node locate(net.bytebuddy.description.method.MethodDescription.SignatureToken token) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.NodeList listNodes() { /* compiled code */ }
&nbsp;
&nbsp;        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;        public int hashCode() { /* compiled code */ }
&nbsp;    }
&nbsp;
&nbsp;    static class NodeList extends net.bytebuddy.matcher.FilterableList.AbstractBase&lt;net.bytebuddy.dynamic.scaffold.MethodGraph.Node,net.bytebuddy.dynamic.scaffold.MethodGraph.NodeList&gt; {
&nbsp;        private final java.util.List&lt;? extends net.bytebuddy.dynamic.scaffold.MethodGraph.Node&gt; nodes;
&nbsp;
&nbsp;        public NodeList(java.util.List&lt;? extends net.bytebuddy.dynamic.scaffold.MethodGraph.Node&gt; nodes) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.Node get(int index) { /* compiled code */ }
&nbsp;
&nbsp;        public int size() { /* compiled code */ }
&nbsp;
&nbsp;        protected net.bytebuddy.dynamic.scaffold.MethodGraph.NodeList wrap(java.util.List&lt;net.bytebuddy.dynamic.scaffold.MethodGraph.Node&gt; values) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.description.method.MethodList&lt;?&gt; asMethodList() { /* compiled code */ }
&nbsp;    }
&nbsp;
&nbsp;    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION&quot;}, justification = &quot;Safe initialization is implied.&quot;)
&nbsp;    static interface Compiler {
&nbsp;        net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler DEFAULT;
&nbsp;
&nbsp;        net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDefinition typeDefinition);
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated
&nbsp;         */
&nbsp;        @java.lang.Deprecated
&nbsp;        net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDescription typeDescription);
&nbsp;
&nbsp;        net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.description.type.TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
<b class="fc">&nbsp;         * @deprecated</b>
&nbsp;         */
&nbsp;        @java.lang.Deprecated
&nbsp;        net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.type.TypeDescription typeDescription1);
&nbsp;
<b class="fc">&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;        static class Default &lt;T&gt; extends net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.AbstractBase {
&nbsp;            private final net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;T&gt; harmonizer;
&nbsp;            private final net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger;
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic.Visitor&lt;? extends net.bytebuddy.description.type.TypeDescription.Generic&gt; visitor;
&nbsp;            private final net.bytebuddy.matcher.ElementMatcher&lt;? super net.bytebuddy.description.method.MethodDescription&gt; matcher;
<b class="nc">&nbsp;</b>
&nbsp;            protected Default(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;T&gt; harmonizer, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger, net.bytebuddy.description.type.TypeDescription.Generic.Visitor&lt;? extends net.bytebuddy.description.type.TypeDescription.Generic&gt; visitor) { /* compiled code */ }
&nbsp;
&nbsp;            public Default(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;T&gt; harmonizer, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger, net.bytebuddy.description.type.TypeDescription.Generic.Visitor&lt;? extends net.bytebuddy.description.type.TypeDescription.Generic&gt; visitor, net.bytebuddy.matcher.ElementMatcher&lt;? super net.bytebuddy.description.method.MethodDescription&gt; matcher) { /* compiled code */ }
&nbsp;
&nbsp;            public static &lt;S&gt; net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler of(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;S&gt; harmonizer, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;            public static &lt;S&gt; net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler of(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;S&gt; harmonizer, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger, net.bytebuddy.matcher.ElementMatcher&lt;? super net.bytebuddy.description.method.MethodDescription&gt; matcher) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public static &lt;S&gt; net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler of(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;S&gt; harmonizer, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger, net.bytebuddy.description.type.TypeDescription.Generic.Visitor&lt;? extends net.bytebuddy.description.type.TypeDescription.Generic&gt; visitor) { /* compiled code */ }
&nbsp;
&nbsp;            public static net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler forJavaHierarchy() { /* compiled code */ }
&nbsp;
&nbsp;            public static net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler forJVMHierarchy() { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.description.type.TypeDescription viewPoint) { /* compiled code */ }
&nbsp;
&nbsp;            protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;T&gt; analyze(net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.description.type.TypeDefinition key, java.util.Map&lt;net.bytebuddy.description.type.TypeDefinition,net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;T&gt;&gt; snapshots, net.bytebuddy.matcher.ElementMatcher&lt;? super net.bytebuddy.description.method.MethodDescription&gt; relevanceMatcher) { /* compiled code */ }
&nbsp;
&nbsp;            protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;T&gt; analyzeNullable(@net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.description.type.TypeDescription.Generic typeDescription, java.util.Map&lt;net.bytebuddy.description.type.TypeDefinition,net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;T&gt;&gt; snapshots, net.bytebuddy.matcher.ElementMatcher&lt;? super net.bytebuddy.description.method.MethodDescription&gt; relevanceMatcher) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;            protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;T&gt; doAnalyze(net.bytebuddy.description.type.TypeDefinition typeDefinition, java.util.Map&lt;net.bytebuddy.description.type.TypeDefinition,net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;T&gt;&gt; snapshots, net.bytebuddy.matcher.ElementMatcher&lt;? super net.bytebuddy.description.method.MethodDescription&gt; relevanceMatcher) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            protected static abstract class Key &lt;S&gt; {
<b class="nc">&nbsp;                protected final java.lang.String internalName;</b>
&nbsp;                protected final int parameterCount;
&nbsp;
&nbsp;                protected Key(java.lang.String internalName, int parameterCount) { /* compiled code */ }
&nbsp;
&nbsp;                protected abstract java.util.Set&lt;S&gt; getIdentifiers();
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object other) { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Store &lt;V&gt; {
&nbsp;                    private final java.util.LinkedHashMap&lt;net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;V&gt;,net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;V&gt;&gt; entries;
&nbsp;
<b class="nc">&nbsp;                    protected Store() { /* compiled code */ }</b>
&nbsp;
&nbsp;                    private Store(java.util.LinkedHashMap&lt;net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;V&gt;,net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;V&gt;&gt; entries) { /* compiled code */ }
&nbsp;
&nbsp;                    private static &lt;W&gt; net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;W&gt; combine(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;W&gt; left, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;W&gt; right) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;V&gt; registerTopLevel(java.util.List&lt;? extends net.bytebuddy.description.method.MethodDescription&gt; methodDescriptions, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;V&gt; harmonizer) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                    protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;V&gt; combineWith(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;V&gt; store) { /* compiled code */ }</b>
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;V&gt; inject(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store&lt;V&gt; store) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.MethodGraph asGraph(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class Graph implements net.bytebuddy.dynamic.scaffold.MethodGraph {
&nbsp;                        private final java.util.LinkedHashMap&lt;net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt;,net.bytebuddy.dynamic.scaffold.MethodGraph.Node&gt; entries;
&nbsp;
&nbsp;                        protected Graph(java.util.LinkedHashMap&lt;net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt;,net.bytebuddy.dynamic.scaffold.MethodGraph.Node&gt; entries) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.dynamic.scaffold.MethodGraph.Node locate(net.bytebuddy.description.method.MethodDescription.SignatureToken token) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.dynamic.scaffold.MethodGraph.NodeList listNodes() { /* compiled code */ }
&nbsp;
&nbsp;                        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                        public int hashCode() { /* compiled code */ }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static interface Entry &lt;W&gt; {
&nbsp;                        net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;W&gt; getKey();
&nbsp;
&nbsp;                        java.util.Set&lt;net.bytebuddy.description.method.MethodDescription&gt; getCandidates();
&nbsp;
&nbsp;                        net.bytebuddy.description.modifier.Visibility getVisibility();
&nbsp;
&nbsp;                        net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;W&gt; extendBy(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;W&gt; harmonizer);
&nbsp;
&nbsp;                        net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;W&gt; inject(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;W&gt; entry);
&nbsp;
&nbsp;                        net.bytebuddy.dynamic.scaffold.MethodGraph.Node asNode(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger);
&nbsp;
&nbsp;                        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                        static class Ambiguous &lt;U&gt; implements net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; {
&nbsp;                            private final net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; key;
&nbsp;                            private final java.util.LinkedHashSet&lt;net.bytebuddy.description.method.MethodDescription&gt; methodDescriptions;
&nbsp;                            private final net.bytebuddy.description.modifier.Visibility visibility;
&nbsp;
&nbsp;                            protected Ambiguous(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; key, java.util.LinkedHashSet&lt;net.bytebuddy.description.method.MethodDescription&gt; methodDescriptions, net.bytebuddy.description.modifier.Visibility visibility) { /* compiled code */ }
&nbsp;
&nbsp;                            protected static &lt;Q&gt; net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;Q&gt; of(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;Q&gt; key, net.bytebuddy.description.method.MethodDescription left, net.bytebuddy.description.method.MethodDescription right, net.bytebuddy.description.modifier.Visibility visibility) { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; getKey() { /* compiled code */ }
&nbsp;
&nbsp;                            public java.util.Set&lt;net.bytebuddy.description.method.MethodDescription&gt; getCandidates() { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.description.modifier.Visibility getVisibility() { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; extendBy(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;U&gt; harmonizer) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; inject(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; entry) { /* compiled code */ }</b>
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Node asNode(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger) { /* compiled code */ }
&nbsp;
&nbsp;                            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                            public int hashCode() { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Node implements net.bytebuddy.dynamic.scaffold.MethodGraph.Node {
&nbsp;                                private final net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Detached key;
&nbsp;                                private final net.bytebuddy.description.method.MethodDescription methodDescription;
&nbsp;                                private final net.bytebuddy.description.modifier.Visibility visibility;
&nbsp;
<b class="fc">&nbsp;                                protected Node(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Detached key, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.description.modifier.Visibility visibility) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
&nbsp;                                public net.bytebuddy.dynamic.scaffold.MethodGraph.Node.Sort getSort() { /* compiled code */ }
&nbsp;
&nbsp;                                public net.bytebuddy.description.method.MethodDescription getRepresentative() { /* compiled code */ }
&nbsp;
&nbsp;                                public java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; getMethodTypes() { /* compiled code */ }
&nbsp;
&nbsp;                                public net.bytebuddy.description.modifier.Visibility getVisibility() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
&nbsp;                                public int hashCode() { /* compiled code */ }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;                        static class Resolved &lt;U&gt; implements net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; {</b>
&nbsp;                            private static final int MADE_VISIBLE = 5;
&nbsp;                            private static final boolean NOT_MADE_VISIBLE = false;
&nbsp;                            private final net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; key;
&nbsp;                            private final net.bytebuddy.description.method.MethodDescription methodDescription;
&nbsp;                            private final net.bytebuddy.description.modifier.Visibility visibility;
&nbsp;                            private final boolean madeVisible;
&nbsp;
&nbsp;                            protected Resolved(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; key, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.description.modifier.Visibility visibility) { /* compiled code */ }
&nbsp;
&nbsp;                            protected Resolved(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; key, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.description.modifier.Visibility visibility, boolean madeVisible) { /* compiled code */ }
&nbsp;
&nbsp;                            private static &lt;V&gt; net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;V&gt; of(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;V&gt; key, net.bytebuddy.description.method.MethodDescription override, net.bytebuddy.description.method.MethodDescription original, net.bytebuddy.description.modifier.Visibility visibility) { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; getKey() { /* compiled code */ }
&nbsp;
&nbsp;                            public java.util.Set&lt;net.bytebuddy.description.method.MethodDescription&gt; getCandidates() { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.description.modifier.Visibility getVisibility() { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; extendBy(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;U&gt; harmonizer) { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; inject(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; entry) { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Node asNode(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger) { /* compiled code */ }
&nbsp;
&nbsp;                            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Node implements net.bytebuddy.dynamic.scaffold.MethodGraph.Node {
&nbsp;                                private final net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Detached key;
&nbsp;                                private final net.bytebuddy.description.method.MethodDescription methodDescription;
&nbsp;                                private final net.bytebuddy.description.modifier.Visibility visibility;
&nbsp;                                private final boolean visible;
&nbsp;
&nbsp;                                protected Node(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Detached key, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.description.modifier.Visibility visibility, boolean visible) { /* compiled code */ }
&nbsp;
&nbsp;                                public net.bytebuddy.dynamic.scaffold.MethodGraph.Node.Sort getSort() { /* compiled code */ }
&nbsp;
&nbsp;                                public net.bytebuddy.description.method.MethodDescription getRepresentative() { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                                public java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; getMethodTypes() { /* compiled code */ }
&nbsp;
&nbsp;                                public net.bytebuddy.description.modifier.Visibility getVisibility() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
&nbsp;                                public int hashCode() { /* compiled code */ }
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;</b>
&nbsp;                        static class Initial &lt;U&gt; implements net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; {
&nbsp;                            private final net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; key;
&nbsp;
&nbsp;                            protected Initial(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; key) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;U&gt; getKey() { /* compiled code */ }
&nbsp;
&nbsp;                            public java.util.Set&lt;net.bytebuddy.description.method.MethodDescription&gt; getCandidates() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                            public net.bytebuddy.description.modifier.Visibility getVisibility() { /* compiled code */ }</b>
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; extendBy(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;U&gt; harmonizer) { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; inject(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Store.Entry&lt;U&gt; entry) { /* compiled code */ }
&nbsp;
&nbsp;                            public net.bytebuddy.dynamic.scaffold.MethodGraph.Node asNode(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger merger) { /* compiled code */ }
&nbsp;
&nbsp;                            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object other) { /* compiled code */ }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class Detached extends net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; {
&nbsp;                    private final java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; identifiers;
&nbsp;
&nbsp;                    protected Detached(java.lang.String internalName, int parameterCount, java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; identifiers) { /* compiled code */ }
&nbsp;
&nbsp;                    protected static net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Detached of(net.bytebuddy.description.method.MethodDescription.SignatureToken token) { /* compiled code */ }
&nbsp;
&nbsp;                    protected java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; getIdentifiers() { /* compiled code */ }
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected static class Harmonized &lt;V&gt; extends net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key&lt;V&gt; {</b>
<b class="fc">&nbsp;                    private final java.util.Map&lt;V,java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt;&gt; identifiers;</b>
<b class="fc">&nbsp;</b>
&nbsp;                    protected Harmonized(java.lang.String internalName, int parameterCount, java.util.Map&lt;V,java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt;&gt; identifiers) { /* compiled code */ }
&nbsp;
&nbsp;                    protected static &lt;Q&gt; net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;Q&gt; of(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;Q&gt; harmonizer) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Detached detach(net.bytebuddy.description.method.MethodDescription.TypeToken typeToken) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;V&gt; combineWith(net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;V&gt; key) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                    protected net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Key.Harmonized&lt;V&gt; extend(net.bytebuddy.description.method.MethodDescription.InDefinedShape methodDescription, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;V&gt; harmonizer) { /* compiled code */ }</b>
&nbsp;
&nbsp;                    protected java.util.Set&lt;V&gt; getIdentifiers() { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static interface Merger {
&nbsp;                net.bytebuddy.description.method.MethodDescription merge(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.description.method.MethodDescription methodDescription1);
&nbsp;
<b class="fc">&nbsp;                static enum Directional implements net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Merger {</b>
&nbsp;                    LEFT, RIGHT;
&nbsp;
&nbsp;                    private final boolean left;
&nbsp;
&nbsp;                    private Directional(boolean left) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.description.method.MethodDescription merge(net.bytebuddy.description.method.MethodDescription left, net.bytebuddy.description.method.MethodDescription right) { /* compiled code */ }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public static interface Harmonizer &lt;S&gt; {
&nbsp;                S harmonize(net.bytebuddy.description.method.MethodDescription.TypeToken typeToken);
&nbsp;
&nbsp;                static enum ForJVMMethod implements net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.Token&gt; {
&nbsp;                    INSTANCE;
<b class="fc">&nbsp;</b>
&nbsp;                    private ForJVMMethod() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.Token harmonize(net.bytebuddy.description.method.MethodDescription.TypeToken typeToken) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                    protected static class Token {</b>
&nbsp;                        private final net.bytebuddy.description.method.MethodDescription.TypeToken typeToken;
&nbsp;                        private final int hashCode;
&nbsp;
&nbsp;                        public Token(net.bytebuddy.description.method.MethodDescription.TypeToken typeToken) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                        public int hashCode() { /* compiled code */ }</b>
&nbsp;
&nbsp;                        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object other) { /* compiled code */ }
&nbsp;
&nbsp;                        public java.lang.String toString() { /* compiled code */ }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                static enum ForJavaMethod implements net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer&lt;net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.Token&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private ForJavaMethod() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.Token harmonize(net.bytebuddy.description.method.MethodDescription.TypeToken typeToken) { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;                    protected static class Token {
&nbsp;                        private final net.bytebuddy.description.method.MethodDescription.TypeToken typeToken;
&nbsp;                        private final int hashCode;
&nbsp;
&nbsp;                        protected Token(net.bytebuddy.description.method.MethodDescription.TypeToken typeToken) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                        public int hashCode() { /* compiled code */ }</b>
&nbsp;
&nbsp;                        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object other) { /* compiled code */ }
&nbsp;
&nbsp;                        public java.lang.String toString() { /* compiled code */ }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static abstract class AbstractBase implements net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler {
&nbsp;            public AbstractBase() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDefinition typeDefinition) { /* compiled code */ }
&nbsp;
&nbsp;            /**
&nbsp;             * @deprecated
&nbsp;             */
&nbsp;            @java.lang.Deprecated
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDescription typeDescription) { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            /**</b>
&nbsp;             * @deprecated
&nbsp;             */
&nbsp;            @java.lang.Deprecated
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDescription typeDefinition, net.bytebuddy.description.type.TypeDescription viewPoint) { /* compiled code */ }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        static enum ForDeclaredMethods implements net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler {</b>
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForDeclaredMethods() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDefinition typeDefinition) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            /**</b>
&nbsp;             * @deprecated
&nbsp;             */
&nbsp;            @java.lang.Deprecated
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDescription typeDescription) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.description.type.TypeDescription viewPoint) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;            /**
&nbsp;             * @deprecated
&nbsp;             */
&nbsp;            @java.lang.Deprecated
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDescription typeDefinition, net.bytebuddy.description.type.TypeDescription viewPoint) { /* compiled code */ }
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    static interface Node {
&nbsp;        net.bytebuddy.dynamic.scaffold.MethodGraph.Node.Sort getSort();
&nbsp;
&nbsp;        net.bytebuddy.description.method.MethodDescription getRepresentative();
&nbsp;
&nbsp;        java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; getMethodTypes();
&nbsp;
&nbsp;        net.bytebuddy.description.modifier.Visibility getVisibility();
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class Simple implements net.bytebuddy.dynamic.scaffold.MethodGraph.Node {
&nbsp;            private final net.bytebuddy.description.method.MethodDescription methodDescription;
<b class="fc">&nbsp;</b>
&nbsp;            public Simple(net.bytebuddy.description.method.MethodDescription methodDescription) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Node.Sort getSort() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.description.method.MethodDescription getRepresentative() { /* compiled code */ }
&nbsp;
&nbsp;            public java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; getMethodTypes() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.description.modifier.Visibility getVisibility() { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        static enum Unresolved implements net.bytebuddy.dynamic.scaffold.MethodGraph.Node {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Unresolved() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Node.Sort getSort() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.description.method.MethodDescription getRepresentative() { /* compiled code */ }
&nbsp;
&nbsp;            public java.util.Set&lt;net.bytebuddy.description.method.MethodDescription.TypeToken&gt; getMethodTypes() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.description.modifier.Visibility getVisibility() { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        static enum Sort {
&nbsp;            VISIBLE, RESOLVED, AMBIGUOUS, UNRESOLVED;
&nbsp;
&nbsp;            private final boolean resolved;
&nbsp;            private final boolean unique;
&nbsp;            private final boolean madeVisible;
&nbsp;
&nbsp;            private Sort(boolean resolved, boolean unique, boolean madeVisible) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean isResolved() { /* compiled code */ }
&nbsp;
&nbsp;            public boolean isUnique() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            public boolean isMadeVisible() { /* compiled code */ }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static interface Linked extends net.bytebuddy.dynamic.scaffold.MethodGraph {
<b class="fc">&nbsp;        net.bytebuddy.dynamic.scaffold.MethodGraph getSuperClassGraph();</b>
&nbsp;
&nbsp;        net.bytebuddy.dynamic.scaffold.MethodGraph getInterfaceGraph(net.bytebuddy.description.type.TypeDescription typeDescription);
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class Delegation implements net.bytebuddy.dynamic.scaffold.MethodGraph.Linked {
<b class="fc">&nbsp;            private final net.bytebuddy.dynamic.scaffold.MethodGraph methodGraph;</b>
&nbsp;            private final net.bytebuddy.dynamic.scaffold.MethodGraph superClassGraph;
&nbsp;            private final java.util.Map&lt;net.bytebuddy.description.type.TypeDescription,net.bytebuddy.dynamic.scaffold.MethodGraph&gt; interfaceGraphs;
&nbsp;
&nbsp;            public Delegation(net.bytebuddy.dynamic.scaffold.MethodGraph methodGraph, net.bytebuddy.dynamic.scaffold.MethodGraph superClassGraph, java.util.Map&lt;net.bytebuddy.description.type.TypeDescription,net.bytebuddy.dynamic.scaffold.MethodGraph&gt; interfaceGraphs) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph getSuperClassGraph() { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph getInterfaceGraph(net.bytebuddy.description.type.TypeDescription typeDescription) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.Node locate(net.bytebuddy.description.method.MethodDescription.SignatureToken token) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.dynamic.scaffold.MethodGraph.NodeList listNodes() { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public int hashCode() { /* compiled code */ }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    static enum Empty implements net.bytebuddy.dynamic.scaffold.MethodGraph.Linked, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler {
&nbsp;        INSTANCE;
&nbsp;
&nbsp;        private Empty() { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.Node locate(net.bytebuddy.description.method.MethodDescription.SignatureToken token) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.NodeList listNodes() { /* compiled code */ }</b>
&nbsp;
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph getSuperClassGraph() { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph getInterfaceGraph(net.bytebuddy.description.type.TypeDescription typeDescription) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDefinition typeDefinition) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;        /**
&nbsp;         * @deprecated
&nbsp;         */
&nbsp;        @java.lang.Deprecated
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDescription typeDescription) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.description.type.TypeDescription viewPoint) { /* compiled code */ }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated
&nbsp;         */
&nbsp;        @java.lang.Deprecated
&nbsp;        public net.bytebuddy.dynamic.scaffold.MethodGraph.Linked compile(net.bytebuddy.description.type.TypeDescription typeDefinition, net.bytebuddy.description.type.TypeDescription viewPoint) { /* compiled code */ }
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-10-10 12:11</div>
</div>
</body>
</html>

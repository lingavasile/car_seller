


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Advice</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.asm</a>
</div>

<h1>Coverage Summary for Class: Advice (net.bytebuddy.asm)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Advice</td>
<td class="coverageStat">
  <span class="percent">
    34.6%
  </span>
  <span class="absValue">
    (9/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    49.5%
  </span>
  <span class="absValue">
    (47/95)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Advice$AdviceVisitor</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.7%
  </span>
  <span class="absValue">
    (41/49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.8%
  </span>
  <span class="absValue">
    (48/58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice$WithExceptionHandling</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/59)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice$WithoutExceptionHandling</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (22/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithoutExitAdvice</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AllArguments</td>
  </tr>
  <tr>
    <td class="name">Advice$Argument</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$Factory$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$Factory$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForAdvice</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForAdvice$Default</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (10/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForAdvice$Default$ForMethodEnter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForAdvice$Default$ForMethodExit</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.8%
  </span>
  <span class="absValue">
    (7/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForInstrumentedMethod</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForInstrumentedMethod$Default</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (14/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForInstrumentedMethod$Default$Copying</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96%
  </span>
  <span class="absValue">
    (24/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$BootstrapArgumentResolver$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$ForRegularInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inactive</td>
<td class="coverageStat">
  <span class="percent">
    13.3%
  </span>
  <span class="absValue">
    (2/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.8%
  </span>
  <span class="absValue">
    (3/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60.6%
  </span>
  <span class="absValue">
    (20/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$CodeTranslationVisitor</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (10/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.2%
  </span>
  <span class="absValue">
    (65/90)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    51.2%
  </span>
  <span class="absValue">
    (21/41)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner$ExceptionTableCollector</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner$ExceptionTableExtractor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner$ExceptionTableSubstitutor</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35%
  </span>
  <span class="absValue">
    (7/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.1%
  </span>
  <span class="absValue">
    (27/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter$WithDiscardedEnterType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter$WithRetainedEnterType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (33/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit$WithExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit$WithoutExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForType</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.8%
  </span>
  <span class="absValue">
    (7/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (28/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$4</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$5</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$6</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$7</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$8</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$Bound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64%
  </span>
  <span class="absValue">
    (16/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$OfDefault</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$OfNonDefault</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Relocation</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Relocation$ForLabel</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodEnter</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodExit</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$Suppressing</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Unresolved</td>
  </tr>
  <tr>
    <td class="name">Advice$Enter</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Exit</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldGetterHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldSetterHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldValue</td>
  </tr>
  <tr>
    <td class="name">Advice$Local</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$Default</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (12/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$Default$ForAdvice</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$Default$WithCopiedArguments</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$ForAdvice</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$ForInstrumentedMethod</td>
  </tr>
  <tr>
    <td class="name">Advice$NoExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory$AdviceType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForAllArguments</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.8%
  </span>
  <span class="absValue">
    (22/47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForAllArguments$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (12/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (9/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (12/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument$Unresolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForEnterValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.6%
  </span>
  <span class="absValue">
    (12/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForEnterValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForExitValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.4%
  </span>
  <span class="absValue">
    (4/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$ReaderFactory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WriterFactory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$2</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$3</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$4</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$5</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedType</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForLocalValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (7/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.3%
  </span>
  <span class="absValue">
    (11/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForReturnValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (14/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForReturnValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForSelfCallHandle$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation$OfDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStubValue</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThisReference</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (14/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThisReference$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThrowable$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForUnusedValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Sort</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Sort$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Sort$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForArray</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForArray$ReadOnly</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue$ReadOnly</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue$ReadWrite</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForStackManipulation</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForStackManipulation$Writable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForVariable$ReadOnly</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForVariable$ReadWrite</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OnDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OnMethodEnter</td>
  </tr>
  <tr>
    <td class="name">Advice$OnMethodExit</td>
  </tr>
  <tr>
    <td class="name">Advice$OnNonDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Origin</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Return</td>
  </tr>
  <tr>
    <td class="name">Advice$SelfCallHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.4%
  </span>
  <span class="absValue">
    (39/73)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$ForAdvice</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.7%
  </span>
  <span class="absValue">
    (23/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$Initialization</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$Initialization$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$Initialization$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$TranslationMode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$TranslationMode$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$TranslationMode$2</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.3%
  </span>
  <span class="absValue">
    (1/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$TranslationMode$3</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$WithPreservedArguments</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.7%
  </span>
  <span class="absValue">
    (24/62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$WithPreservedArguments$WithArgumentCopy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50.6%
  </span>
  <span class="absValue">
    (40/79)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$ForAdvice</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$ForInstrumentedMethod</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$ForPostProcessor</td>
  </tr>
  <tr>
    <td class="name">Advice$StubValue</td>
  </tr>
  <tr>
    <td class="name">Advice$This</td>
  </tr>
  <tr>
    <td class="name">Advice$Thrown</td>
  </tr>
  <tr>
    <td class="name">Advice$Unused</td>
  </tr>
  <tr>
    <td class="name">Advice$WithCustomMapping</td>
<td class="coverageStat">
  <span class="percent">
    14.9%
  </span>
  <span class="absValue">
    (7/47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    13.7%
  </span>
  <span class="absValue">
    (13/95)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    57.5%
  </span>
  <span class="absValue">
    (304/529)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53%
  </span>
  <span class="absValue">
    (992/1872)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;
&nbsp;  // IntelliJ API Decompiler stub source generated from a class file
&nbsp;  // Implementation of methods is not available
&nbsp;
&nbsp;package net.bytebuddy.asm;
&nbsp;
&nbsp;@net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;public class Advice implements net.bytebuddy.asm.AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper, net.bytebuddy.implementation.Implementation {
&nbsp;    @net.bytebuddy.utility.nullability.AlwaysNull
&nbsp;    private static final net.bytebuddy.jar.asm.ClassReader UNDEFINED;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape SKIP_ON;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape SKIP_ON_INDEX;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape PREPEND_LINE_NUMBER;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape INLINE_ENTER;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape SUPPRESS_ENTER;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape REPEAT_ON;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape REPEAT_ON_INDEX;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ON_THROWABLE;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape BACKUP_ARGUMENTS;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape INLINE_EXIT;
&nbsp;    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape SUPPRESS_EXIT;
&nbsp;    private final net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter methodEnter;
&nbsp;    private final net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit methodExit;
&nbsp;    private final net.bytebuddy.implementation.bytecode.assign.Assigner assigner;
&nbsp;    private final net.bytebuddy.asm.Advice.ExceptionHandler exceptionHandler;
&nbsp;    private final net.bytebuddy.implementation.Implementation delegate;
&nbsp;
&nbsp;    protected Advice(net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter methodEnter, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit methodExit) { /* compiled code */ }
&nbsp;
&nbsp;    private Advice(net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter methodEnter, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit methodExit, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ExceptionHandler exceptionHandler, net.bytebuddy.implementation.Implementation delegate) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice to(java.lang.Class&lt;?&gt; advice) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice to(java.lang.Class&lt;?&gt; advice, net.bytebuddy.dynamic.ClassFileLocator classFileLocator) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription advice) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription advice, net.bytebuddy.dynamic.ClassFileLocator classFileLocator) { /* compiled code */ }
&nbsp;
&nbsp;    protected static net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription advice, net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory, net.bytebuddy.dynamic.ClassFileLocator classFileLocator, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.asm.Advice.Delegator.Factory delegatorFactory) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice to(java.lang.Class&lt;?&gt; enterAdvice, java.lang.Class&lt;?&gt; exitAdvice) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice to(java.lang.Class&lt;?&gt; enterAdvice, java.lang.Class&lt;?&gt; exitAdvice, net.bytebuddy.dynamic.ClassFileLocator classFileLocator) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription enterAdvice, net.bytebuddy.description.type.TypeDescription exitAdvice) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription enterAdvice, net.bytebuddy.description.type.TypeDescription exitAdvice, net.bytebuddy.dynamic.ClassFileLocator classFileLocator) { /* compiled code */ }
&nbsp;
&nbsp;    protected static net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription enterAdvice, net.bytebuddy.description.type.TypeDescription exitAdvice, net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory, net.bytebuddy.dynamic.ClassFileLocator classFileLocator, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.asm.Advice.Delegator.Factory delegatorFactory) { /* compiled code */ }
&nbsp;
&nbsp;    private static net.bytebuddy.asm.Advice.Dispatcher.Unresolved locate(java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt; type, net.bytebuddy.description.method.MethodDescription.InDefinedShape property, net.bytebuddy.asm.Advice.Dispatcher.Unresolved dispatcher, net.bytebuddy.description.method.MethodDescription.InDefinedShape methodDescription, net.bytebuddy.asm.Advice.Delegator.Factory delegatorFactory) { /* compiled code */ }
&nbsp;
&nbsp;    public static net.bytebuddy.asm.Advice.WithCustomMapping withCustomMapping() { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.asm.AsmVisitorWrapper.ForDeclaredMethods on(net.bytebuddy.matcher.ElementMatcher&lt;? super net.bytebuddy.description.method.MethodDescription&gt; matcher) { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.jar.asm.MethodVisitor wrap(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.pool.TypePool typePool, int writerFlags, int readerFlags) { /* compiled code */ }
&nbsp;
&nbsp;    protected net.bytebuddy.jar.asm.MethodVisitor doWrap(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, int writerFlags, int readerFlags) { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.dynamic.scaffold.InstrumentedType prepare(net.bytebuddy.dynamic.scaffold.InstrumentedType instrumentedType) { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.implementation.bytecode.ByteCodeAppender appender(net.bytebuddy.implementation.Implementation.Target implementationTarget) { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.asm.Advice withAssigner(net.bytebuddy.implementation.bytecode.assign.Assigner assigner) { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.asm.Advice withExceptionPrinting() { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.asm.Advice withExceptionHandler(net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.asm.Advice withExceptionHandler(net.bytebuddy.asm.Advice.ExceptionHandler exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;    public net.bytebuddy.implementation.Implementation wrap(net.bytebuddy.implementation.Implementation implementation) { /* compiled code */ }
&nbsp;
&nbsp;    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;    public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;    public static final class OnNonDefaultValue {
&nbsp;        private OnNonDefaultValue() { /* compiled code */ }
&nbsp;    }
&nbsp;
&nbsp;    public static final class OnDefaultValue {
&nbsp;        private OnDefaultValue() { /* compiled code */ }
&nbsp;    }
&nbsp;
&nbsp;    private static class NoExceptionHandler extends java.lang.Throwable {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private static final net.bytebuddy.description.type.TypeDescription DESCRIPTION;
&nbsp;
&nbsp;        private NoExceptionHandler() { /* compiled code */ }
&nbsp;    }
&nbsp;
&nbsp;    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class WithCustomMapping {
&nbsp;        private final net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory;
&nbsp;        private final net.bytebuddy.asm.Advice.Delegator.Factory delegatorFactory;
&nbsp;        private final java.util.Map&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;,net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings;
&nbsp;
&nbsp;        protected WithCustomMapping() { /* compiled code */ }
&nbsp;
&nbsp;        protected WithCustomMapping(net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory, java.util.Map&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;,net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings, net.bytebuddy.asm.Advice.Delegator.Factory delegatorFactory) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object value) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, java.lang.reflect.Field field) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.description.field.FieldDescription fieldDescription) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, java.lang.reflect.Method method, int index) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, java.lang.reflect.Constructor&lt;?&gt; constructor, int index) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.description.method.ParameterDescription parameterDescription) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, java.lang.Class&lt;?&gt; value) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.description.type.TypeDescription value) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, java.lang.Enum&lt;?&gt; value) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.description.enumeration.EnumerationDescription value) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindSerialized(java.lang.Class&lt;T&gt; type, java.io.Serializable value) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation, S extends java.io.Serializable&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindSerialized(java.lang.Class&lt;T&gt; type, S value, java.lang.Class&lt;? super S&gt; targetType) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindProperty(java.lang.Class&lt;T&gt; type, java.lang.String property) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.utility.JavaConstant constant) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.utility.ConstantValue constant) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, java.lang.reflect.Type targetType) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.description.type.TypeDescription.Generic targetType) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindLambda(java.lang.Class&lt;T&gt; type, java.lang.reflect.Constructor&lt;?&gt; constructor, java.lang.Class&lt;?&gt; functionalInterface) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindLambda(java.lang.Class&lt;T&gt; type, java.lang.reflect.Constructor&lt;?&gt; constructor, java.lang.Class&lt;?&gt; functionalInterface, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler methodGraphCompiler) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindLambda(java.lang.Class&lt;T&gt; type, java.lang.reflect.Method method, java.lang.Class&lt;?&gt; functionalInterface) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindLambda(java.lang.Class&lt;T&gt; type, java.lang.reflect.Method method, java.lang.Class&lt;?&gt; functionalInterface, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler methodGraphCompiler) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindLambda(java.lang.Class&lt;T&gt; type, net.bytebuddy.description.method.MethodDescription.InDefinedShape methodDescription, net.bytebuddy.description.type.TypeDescription functionalInterface) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindLambda(java.lang.Class&lt;T&gt; type, net.bytebuddy.description.method.MethodDescription.InDefinedShape methodDescription, net.bytebuddy.description.type.TypeDescription functionalInterface, net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler methodGraphCompiler) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindDynamic(java.lang.Class&lt;T&gt; type, java.lang.reflect.Method bootstrapMethod, java.lang.Object... constant) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindDynamic(java.lang.Class&lt;T&gt; type, java.lang.reflect.Method bootstrapMethod, java.util.List&lt;?&gt; constants) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindDynamic(java.lang.Class&lt;T&gt; type, java.lang.reflect.Constructor&lt;?&gt; bootstrapMethod, java.lang.Object... constant) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindDynamic(java.lang.Class&lt;T&gt; type, java.lang.reflect.Constructor&lt;?&gt; bootstrapMethod, java.util.List&lt;?&gt; constants) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindDynamic(java.lang.Class&lt;T&gt; type, net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod, java.lang.Object... constant) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bindDynamic(java.lang.Class&lt;T&gt; type, net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod, java.util.List&lt;?&gt; constants) { /* compiled code */ }
&nbsp;
&nbsp;        public &lt;T extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.WithCustomMapping bind(java.lang.Class&lt;T&gt; type, net.bytebuddy.asm.Advice.OffsetMapping offsetMapping) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice.WithCustomMapping bind(net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt; offsetMapping) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice.WithCustomMapping bootstrap(java.lang.reflect.Constructor&lt;?&gt; constructor) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice.WithCustomMapping bootstrap(java.lang.reflect.Constructor&lt;?&gt; constructor, net.bytebuddy.asm.Advice.BootstrapArgumentResolver.Factory resolverFactory) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice.WithCustomMapping bootstrap(java.lang.reflect.Method method) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice.WithCustomMapping bootstrap(java.lang.reflect.Method method, net.bytebuddy.asm.Advice.BootstrapArgumentResolver.Factory resolver) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice.WithCustomMapping bootstrap(net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrap) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice.WithCustomMapping bootstrap(net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrap, net.bytebuddy.asm.Advice.BootstrapArgumentResolver.Factory resolverFactory) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice.WithCustomMapping with(net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice to(java.lang.Class&lt;?&gt; advice) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice to(java.lang.Class&lt;?&gt; advice, net.bytebuddy.dynamic.ClassFileLocator classFileLocator) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription advice, net.bytebuddy.dynamic.ClassFileLocator classFileLocator) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice to(java.lang.Class&lt;?&gt; enterAdvice, java.lang.Class&lt;?&gt; exitAdvice) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice to(java.lang.Class&lt;?&gt; enterAdvice, java.lang.Class&lt;?&gt; exitAdvice, net.bytebuddy.dynamic.ClassFileLocator classFileLocator) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription enterAdvice, net.bytebuddy.description.type.TypeDescription exitAdvice) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.asm.Advice to(net.bytebuddy.description.type.TypeDescription enterAdvice, net.bytebuddy.description.type.TypeDescription exitAdvice, net.bytebuddy.dynamic.ClassFileLocator classFileLocator) { /* compiled code */ }
&nbsp;
&nbsp;        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;        public int hashCode() { /* compiled code */ }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static abstract class AssignReturned implements net.bytebuddy.asm.Advice.PostProcessor {
&nbsp;        public static final int NO_INDEX = -1;
&nbsp;        protected final net.bytebuddy.description.type.TypeDescription.Generic type;
<b class="fc">&nbsp;        protected final net.bytebuddy.asm.Advice.AssignReturned.ExceptionHandler.Factory exceptionHandlerFactory;</b>
&nbsp;        protected final boolean exit;
&nbsp;        protected final boolean skipOnDefaultValue;
&nbsp;
&nbsp;        protected AssignReturned(net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.asm.Advice.AssignReturned.ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, boolean skipOnDefaultValue) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;        protected abstract net.bytebuddy.description.type.TypeDescription.Generic getType();
&nbsp;
&nbsp;        protected abstract java.util.Collection&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; getHandlers();
&nbsp;
&nbsp;        protected abstract net.bytebuddy.implementation.bytecode.StackManipulation toLoadInstruction(net.bytebuddy.asm.Advice.AssignReturned.Handler handler, int i);
&nbsp;
&nbsp;        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;        public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        public static class Factory implements net.bytebuddy.asm.Advice.PostProcessor.Factory {
&nbsp;            private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape SKIP_ON_DEFAULT_VALUE;
&nbsp;            private final java.util.List&lt;? extends net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;?&gt;&gt; factories;
&nbsp;            private final net.bytebuddy.asm.Advice.AssignReturned.ExceptionHandler.Factory exceptionHandlerFactory;
&nbsp;
&nbsp;            public Factory() { /* compiled code */ }
&nbsp;
&nbsp;            protected Factory(java.util.List&lt;? extends net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;?&gt;&gt; factories, net.bytebuddy.asm.Advice.AssignReturned.ExceptionHandler.Factory exceptionHandlerFactory) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.AssignReturned.Factory with(java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt; type, net.bytebuddy.asm.Advice.AssignReturned.Handler... handler) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.AssignReturned.Factory with(java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt; type, java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; handlers) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.AssignReturned.Factory with(net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;?&gt; factory) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.PostProcessor.Factory withSuppressed(java.lang.Class&lt;? extends java.lang.Throwable&gt; exceptionType) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.PostProcessor.Factory withSuppressed(net.bytebuddy.description.type.TypeDescription exceptionType) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.PostProcessor make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        public static interface Handler {
&nbsp;            int getIndex();
&nbsp;
&nbsp;            net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.description.type.TypeDescription.Generic generic, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation);
&nbsp;
&nbsp;            static interface Factory &lt;T extends java.lang.annotation.Annotation&gt; {
&nbsp;                java.lang.Class&lt;T&gt; getAnnotationType();
&nbsp;
&nbsp;                java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; make(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape, boolean b, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;? extends T&gt; loadable);
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                static class Simple &lt;S extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;S&gt; {
&nbsp;                    private final java.lang.Class&lt;S&gt; type;
&nbsp;                    private final java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; handlers;
&nbsp;
&nbsp;                    public Simple(java.lang.Class&lt;S&gt; type, java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; handlers) { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public java.lang.Class&lt;S&gt; getAnnotationType() { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;? extends S&gt; annotation) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public int hashCode() { /* compiled code */ }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;        protected static class ExceptionHandler implements net.bytebuddy.implementation.bytecode.StackManipulation {
&nbsp;            private final net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation;
&nbsp;            private final net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler;
&nbsp;            private final net.bytebuddy.description.type.TypeDescription exceptionType;
&nbsp;            private final net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler;
&nbsp;
&nbsp;            protected ExceptionHandler(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.description.type.TypeDescription exceptionType, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean isValid() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.implementation.bytecode.StackManipulation.Size apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            public static interface Factory {
&nbsp;                net.bytebuddy.implementation.bytecode.StackManipulation wrap(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation1, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor forPostProcessor);
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                static class Enabled implements net.bytebuddy.asm.Advice.AssignReturned.ExceptionHandler.Factory {
&nbsp;                    private final net.bytebuddy.description.type.TypeDescription exceptionType;
&nbsp;
&nbsp;                    protected Enabled(net.bytebuddy.description.type.TypeDescription exceptionType) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation wrap(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                static enum NoOp implements net.bytebuddy.asm.Advice.AssignReturned.ExceptionHandler.Factory {
&nbsp;                    INSTANCE;
<b class="fc">&nbsp;</b>
&nbsp;                    private NoOp() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation wrap(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class DefaultValueSkip implements net.bytebuddy.implementation.bytecode.StackManipulation {
&nbsp;            private final net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation;
&nbsp;            private final net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler;
&nbsp;            private final int offset;
&nbsp;            private final net.bytebuddy.asm.Advice.AssignReturned.DefaultValueSkip.Dispatcher dispatcher;
&nbsp;
&nbsp;            protected DefaultValueSkip(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, int offset, net.bytebuddy.asm.Advice.AssignReturned.DefaultValueSkip.Dispatcher dispatcher) { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            protected static net.bytebuddy.implementation.bytecode.StackManipulation of(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, int offset, net.bytebuddy.description.type.TypeDefinition typeDefinition) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public boolean isValid() { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public net.bytebuddy.implementation.bytecode.StackManipulation.Size apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            protected static abstract enum Dispatcher {
&nbsp;                INTEGER, LONG, FLOAT, DOUBLE, REFERENCE;
&nbsp;
&nbsp;                private Dispatcher() { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                protected abstract net.bytebuddy.implementation.bytecode.StackManipulation.Size apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, int i, net.bytebuddy.jar.asm.Label label);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ForScalar extends net.bytebuddy.asm.Advice.AssignReturned {
&nbsp;            private final java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; handlers;
&nbsp;
&nbsp;            protected ForScalar(net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.asm.Advice.AssignReturned.ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, boolean skipOnDefaultValue, java.util.Collection&lt;java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt;&gt; handlers) { /* compiled code */ }
&nbsp;
&nbsp;            protected net.bytebuddy.description.type.TypeDescription.Generic getType() { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;            protected java.util.Collection&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; getHandlers() { /* compiled code */ }
&nbsp;
&nbsp;            protected net.bytebuddy.implementation.bytecode.StackManipulation toLoadInstruction(net.bytebuddy.asm.Advice.AssignReturned.Handler handler, int offset) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ForArray extends net.bytebuddy.asm.Advice.AssignReturned {
<b class="nc">&nbsp;            private final java.util.Map&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler,java.lang.Integer&gt; handlers;</b>
&nbsp;
&nbsp;            protected ForArray(net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.asm.Advice.AssignReturned.ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, java.util.Collection&lt;java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt;&gt; handlers) { /* compiled code */ }
&nbsp;
&nbsp;            @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            protected net.bytebuddy.description.type.TypeDescription.Generic getType() { /* compiled code */ }
&nbsp;
&nbsp;            protected java.util.Collection&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; getHandlers() { /* compiled code */ }
&nbsp;
&nbsp;            @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            protected net.bytebuddy.implementation.bytecode.StackManipulation toLoadInstruction(net.bytebuddy.asm.Advice.AssignReturned.Handler handler, int offset) { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        @java.lang.annotation.Documented
&nbsp;        @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
&nbsp;        public static @interface ToThrown {
&nbsp;            int index() default -1;
&nbsp;
&nbsp;            net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Handler implements net.bytebuddy.asm.Advice.AssignReturned.Handler {
&nbsp;                private final int index;
&nbsp;                private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected Handler(int index, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public int getIndex() { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.implementation.bytecode.StackManipulation value) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                public int hashCode() { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
&nbsp;                public static enum Factory implements net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;net.bytebuddy.asm.Advice.AssignReturned.ToThrown&gt; {
<b class="fc">&nbsp;                    INSTANCE;</b>
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_THROWN_INDEX;</b>
<b class="nc">&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_THROWN_TYPING;</b>
&nbsp;
&nbsp;                    private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.AssignReturned.ToThrown&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    public java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;? extends net.bytebuddy.asm.Advice.AssignReturned.ToThrown&gt; annotation) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @java.lang.annotation.Documented
<b class="nc">&nbsp;        @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</b>
<b class="nc">&nbsp;        @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})</b>
<b class="nc">&nbsp;        public static @interface ToReturned {</b>
<b class="nc">&nbsp;            int index() default -1;</b>
&nbsp;
&nbsp;            net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Handler implements net.bytebuddy.asm.Advice.AssignReturned.Handler {
&nbsp;                private final int index;
&nbsp;                private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
&nbsp;                protected Handler(int index, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;                public int getIndex() { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.implementation.bytecode.StackManipulation value) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                public static enum Factory implements net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;net.bytebuddy.asm.Advice.AssignReturned.ToReturned&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_RETURNED_INDEX;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_RETURNED_TYPING;
&nbsp;
<b class="nc">&nbsp;                    private Factory() { /* compiled code */ }</b>
&nbsp;
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.AssignReturned.ToReturned&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;? extends net.bytebuddy.asm.Advice.AssignReturned.ToReturned&gt; annotation) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @java.lang.annotation.Documented
&nbsp;        @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
<b class="nc">&nbsp;        public static @interface ToFields {</b>
&nbsp;            net.bytebuddy.asm.Advice.AssignReturned.ToFields.ToField[] value();
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Handler implements net.bytebuddy.asm.Advice.AssignReturned.Handler {
&nbsp;                private final int index;
&nbsp;                private final java.lang.String name;
&nbsp;                private final net.bytebuddy.description.type.TypeDescription declaringType;
&nbsp;                private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
&nbsp;                protected Handler(int index, java.lang.String name, net.bytebuddy.description.type.TypeDescription declaringType, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;                public int getIndex() { /* compiled code */ }
&nbsp;
&nbsp;                @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.implementation.bytecode.StackManipulation value) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public static enum Factory implements net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;net.bytebuddy.asm.Advice.AssignReturned.ToFields&gt; {</b>
<b class="nc">&nbsp;                    INSTANCE;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_FIELDS_VALUE;</b>
<b class="nc">&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_FIELD_VALUE;</b>
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_FIELD_INDEX;
<b class="nc">&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_FIELD_DECLARING_TYPE;</b>
<b class="nc">&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_FIELD_TYPING;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    private Factory() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.AssignReturned.ToFields&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                    public java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;? extends net.bytebuddy.asm.Advice.AssignReturned.ToFields&gt; annotation) { /* compiled code */ }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            @java.lang.annotation.Target({})
<b class="nc">&nbsp;            @net.bytebuddy.build.RepeatedAnnotationPlugin.Enhance(net.bytebuddy.asm.Advice.AssignReturned.ToFields.class)</b>
<b class="nc">&nbsp;            @java.lang.annotation.Repeatable(net.bytebuddy.asm.Advice.AssignReturned.ToFields.class)</b>
&nbsp;            static @interface ToField {
&nbsp;                java.lang.String value() default &quot;&quot;;
&nbsp;
&nbsp;                java.lang.Class&lt;?&gt; declaringType() default void.class;
&nbsp;
&nbsp;                int index() default -1;
&nbsp;
&nbsp;                net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @java.lang.annotation.Documented
&nbsp;        @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
&nbsp;        public static @interface ToThis {
&nbsp;            int index() default -1;
&nbsp;
&nbsp;            net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
<b class="fc">&nbsp;            static class Handler implements net.bytebuddy.asm.Advice.AssignReturned.Handler {</b>
<b class="fc">&nbsp;                private final int index;</b>
<b class="nc">&nbsp;                private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;</b>
<b class="fc">&nbsp;                private final boolean exit;</b>
<b class="nc">&nbsp;</b>
&nbsp;                protected Handler(int index, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, boolean exit) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                public int getIndex() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.implementation.bytecode.StackManipulation value) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                public static enum Factory implements net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;net.bytebuddy.asm.Advice.AssignReturned.ToThis&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_THIS_INDEX;
<b class="fc">&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_THIS_TYPING;</b>
&nbsp;
&nbsp;                    private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.AssignReturned.ToThis&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;? extends net.bytebuddy.asm.Advice.AssignReturned.ToThis&gt; annotation) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @java.lang.annotation.Documented
&nbsp;        @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
&nbsp;        public static @interface ToAllArguments {
&nbsp;            int index() default -1;
&nbsp;
&nbsp;            net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Handler implements net.bytebuddy.asm.Advice.AssignReturned.Handler {
&nbsp;                private final int index;
&nbsp;                private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
<b class="fc">&nbsp;</b>
&nbsp;                protected Handler(int index, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                public int getIndex() { /* compiled code */ }
&nbsp;
&nbsp;                @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.implementation.bytecode.StackManipulation value) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                public static enum Factory implements net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;net.bytebuddy.asm.Advice.AssignReturned.ToAllArguments&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_ALL_ARGUMENTS_INDEX;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_ALL_ARGUMENTS_TYPING;
&nbsp;
&nbsp;                    private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.AssignReturned.ToAllArguments&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                    public java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;? extends net.bytebuddy.asm.Advice.AssignReturned.ToAllArguments&gt; annotation) { /* compiled code */ }</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        @java.lang.annotation.Documented
&nbsp;        @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
<b class="nc">&nbsp;        @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})</b>
&nbsp;        public static @interface ToArguments {
&nbsp;            net.bytebuddy.asm.Advice.AssignReturned.ToArguments.ToArgument[] value();
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Handler implements net.bytebuddy.asm.Advice.AssignReturned.Handler {
<b class="fc">&nbsp;                private final int value;</b>
<b class="fc">&nbsp;                private final int index;</b>
&nbsp;                private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
<b class="fc">&nbsp;                protected Handler(int value, int index, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }</b>
&nbsp;
&nbsp;                public int getIndex() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.description.type.TypeDescription.Generic type, net.bytebuddy.implementation.bytecode.StackManipulation value) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public int hashCode() { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                public static enum Factory implements net.bytebuddy.asm.Advice.AssignReturned.Handler.Factory&lt;net.bytebuddy.asm.Advice.AssignReturned.ToArguments&gt; {</b>
&nbsp;                    INSTANCE;
&nbsp;
<b class="nc">&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_ARGUMENTS_VALUE;</b>
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_ARGUMENT_VALUE;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_ARGUMENT_INDEX;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape TO_ARGUMENT_TYPING;
&nbsp;
&nbsp;                    private Factory() { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.AssignReturned.ToArguments&gt; getAnnotationType() { /* compiled code */ }</b>
&nbsp;
&nbsp;                    public java.util.List&lt;net.bytebuddy.asm.Advice.AssignReturned.Handler&gt; make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;? extends net.bytebuddy.asm.Advice.AssignReturned.ToArguments&gt; annotation) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @java.lang.annotation.Target({})
&nbsp;            @net.bytebuddy.build.RepeatedAnnotationPlugin.Enhance(net.bytebuddy.asm.Advice.AssignReturned.ToArguments.class)
<b class="nc">&nbsp;            @java.lang.annotation.Repeatable(net.bytebuddy.asm.Advice.AssignReturned.ToArguments.class)</b>
&nbsp;            static @interface ToArgument {
&nbsp;                int value();
&nbsp;
&nbsp;                int index() default -1;
&nbsp;
&nbsp;                net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @java.lang.annotation.Documented
&nbsp;        @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
&nbsp;        public static @interface AsScalar {
&nbsp;            boolean skipOnDefaultValue() default true;
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface Unused {
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
<b class="nc">&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})</b>
&nbsp;    public static @interface StubValue {
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface Local {
&nbsp;        java.lang.String value();
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @java.lang.annotation.Documented</b>
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface Exit {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
<b class="nc">&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})</b>
&nbsp;    public static @interface Enter {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
<b class="nc">&nbsp;    public static @interface Origin {</b>
&nbsp;        java.lang.String DEFAULT = &quot;&quot;;
&nbsp;
&nbsp;        java.lang.String value() default &quot;&quot;;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface FieldSetterHandle {
&nbsp;        java.lang.String value() default &quot;&quot;;
&nbsp;
&nbsp;        java.lang.Class&lt;?&gt; declaringType() default void.class;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface FieldGetterHandle {
&nbsp;        java.lang.String value() default &quot;&quot;;
&nbsp;
&nbsp;        java.lang.Class&lt;?&gt; declaringType() default void.class;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface FieldValue {
&nbsp;        java.lang.String value() default &quot;&quot;;
&nbsp;
&nbsp;        java.lang.Class&lt;?&gt; declaringType() default void.class;
&nbsp;
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface SelfCallHandle {
&nbsp;        boolean bound() default true;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface Thrown {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.DYNAMIC;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface Return {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface AllArguments {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;
&nbsp;        boolean includeSelf() default false;
&nbsp;
&nbsp;        boolean nullIfEmpty() default false;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface Argument {
&nbsp;        int value();
&nbsp;
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;
&nbsp;
&nbsp;        boolean optional() default false;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.PARAMETER})
&nbsp;    public static @interface This {
&nbsp;        boolean readOnly() default true;
&nbsp;
<b class="fc">&nbsp;        net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing() default net.bytebuddy.implementation.bytecode.assign.Assigner.Typing.STATIC;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        boolean optional() default false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
&nbsp;    public static @interface OnMethodExit {
<b class="nc">&nbsp;        java.lang.Class&lt;?&gt; repeatOn() default void.class;</b>
&nbsp;
&nbsp;        int repeatOnIndex() default -1;
&nbsp;
&nbsp;        java.lang.Class&lt;? extends java.lang.Throwable&gt; onThrowable() default net.bytebuddy.asm.Advice.NoExceptionHandler.class;
&nbsp;
&nbsp;        boolean backupArguments() default true;
&nbsp;
&nbsp;        boolean inline() default true;
&nbsp;
&nbsp;        java.lang.Class&lt;? extends java.lang.Throwable&gt; suppress() default net.bytebuddy.asm.Advice.NoExceptionHandler.class;
&nbsp;    }
&nbsp;
&nbsp;    @java.lang.annotation.Documented
<b class="nc">&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</b>
&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
&nbsp;    public static @interface OnMethodEnter {
&nbsp;        java.lang.Class&lt;?&gt; skipOn() default void.class;
&nbsp;
&nbsp;        int skipOnIndex() default -1;
&nbsp;
&nbsp;        boolean prependLineNumber() default true;
&nbsp;
&nbsp;        boolean inline() default true;
<b class="nc">&nbsp;</b>
&nbsp;        java.lang.Class&lt;? extends java.lang.Throwable&gt; suppress() default net.bytebuddy.asm.Advice.NoExceptionHandler.class;
&nbsp;    }
&nbsp;
&nbsp;    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class Appender implements net.bytebuddy.implementation.bytecode.ByteCodeAppender {
&nbsp;        private final net.bytebuddy.asm.Advice advice;
<b class="nc">&nbsp;        private final net.bytebuddy.implementation.Implementation.Target implementationTarget;</b>
&nbsp;        private final net.bytebuddy.implementation.bytecode.ByteCodeAppender delegate;
&nbsp;
&nbsp;        protected Appender(net.bytebuddy.asm.Advice advice, net.bytebuddy.implementation.Implementation.Target implementationTarget, net.bytebuddy.implementation.bytecode.ByteCodeAppender delegate) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.implementation.bytecode.ByteCodeAppender.Size apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
&nbsp;        public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;        protected static class EmulatingMethodVisitor extends net.bytebuddy.jar.asm.MethodVisitor {
&nbsp;            private final net.bytebuddy.implementation.bytecode.ByteCodeAppender delegate;
&nbsp;            private int stackSize;
&nbsp;            private int localVariableLength;
&nbsp;
&nbsp;            protected EmulatingMethodVisitor(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.bytecode.ByteCodeAppender delegate) { /* compiled code */ }
&nbsp;
&nbsp;            protected net.bytebuddy.implementation.bytecode.ByteCodeAppender.Size resolve(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;
&nbsp;            public void visitCode() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            public void visitMaxs(int stackSize, int localVariableLength) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public void visitEnd() { /* compiled code */ }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected static abstract class AdviceVisitor extends net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor implements net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation {
&nbsp;        private static final int THIS_VARIABLE_INDEX = 0;
&nbsp;        private static final java.lang.String THIS_VARIABLE_NAME = &quot;this&quot;;
&nbsp;        protected final net.bytebuddy.description.method.MethodDescription instrumentedMethod;
<b class="fc">&nbsp;        private final net.bytebuddy.jar.asm.Label preparationStart;</b>
&nbsp;        private final net.bytebuddy.asm.Advice.Dispatcher.Bound methodEnter;
&nbsp;        protected final net.bytebuddy.asm.Advice.Dispatcher.Bound methodExit;
&nbsp;        protected final net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler;
&nbsp;        protected final net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler;
&nbsp;        protected final net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler;
&nbsp;
<b class="fc">&nbsp;        @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;MC_OVERRIDABLE_METHOD_CALL_IN_CONSTRUCTOR&quot;}, justification = &quot;Self reference is not used before constructor completion.&quot;)</b>
&nbsp;        protected AdviceVisitor(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter methodEnter, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit methodExit, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes, int writerFlags, int readerFlags) { /* compiled code */ }
&nbsp;
&nbsp;        protected void onAfterExceptionTable() { /* compiled code */ }
&nbsp;
&nbsp;        protected abstract void onUserPrepare();
&nbsp;
<b class="nc">&nbsp;        protected abstract void onUserStart();</b>
&nbsp;
&nbsp;        protected void onVisitVarInsn(int opcode, int offset) { /* compiled code */ }
&nbsp;
&nbsp;        protected void onVisitIincInsn(int offset, int increment) { /* compiled code */ }
&nbsp;
&nbsp;        public void onVisitFrame(int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }
&nbsp;
&nbsp;        public void visitMaxs(int stackSize, int localVariableLength) { /* compiled code */ }
&nbsp;
&nbsp;        public void visitLocalVariable(java.lang.String name, java.lang.String descriptor, java.lang.String signature, net.bytebuddy.jar.asm.Label start, net.bytebuddy.jar.asm.Label end, int offset) { /* compiled code */ }
&nbsp;
&nbsp;        public net.bytebuddy.jar.asm.AnnotationVisitor visitLocalVariableAnnotation(int typeReference, net.bytebuddy.jar.asm.TypePath typePath, net.bytebuddy.jar.asm.Label[] start, net.bytebuddy.jar.asm.Label[] end, int[] offset, java.lang.String descriptor, boolean visible) { /* compiled code */ }
&nbsp;
&nbsp;        protected abstract void onUserEnd();
&nbsp;
&nbsp;        protected static abstract class WithExitAdvice extends net.bytebuddy.asm.Advice.AdviceVisitor {
&nbsp;            protected final net.bytebuddy.jar.asm.Label returnHandler;
&nbsp;
&nbsp;            protected WithExitAdvice(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter methodEnter, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit methodExit, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes, int writerFlags, int readerFlags) { /* compiled code */ }
&nbsp;
&nbsp;            public void apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;            protected void onVisitInsn(int opcode) { /* compiled code */ }
&nbsp;
&nbsp;            protected void onUserEnd() { /* compiled code */ }
&nbsp;
&nbsp;            protected abstract void onUserReturn();
&nbsp;
&nbsp;            protected abstract void onExitAdviceReturn();
&nbsp;
&nbsp;            protected static class WithExceptionHandling extends net.bytebuddy.asm.Advice.AdviceVisitor.WithExitAdvice {
&nbsp;                private final net.bytebuddy.description.type.TypeDescription throwable;
<b class="fc">&nbsp;                private final net.bytebuddy.jar.asm.Label exceptionHandler;</b>
<b class="fc">&nbsp;                protected final net.bytebuddy.jar.asm.Label userStart;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected WithExceptionHandling(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter methodEnter, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit methodExit, int writerFlags, int readerFlags, net.bytebuddy.description.type.TypeDescription throwable) { /* compiled code */ }</b>
&nbsp;
&nbsp;                protected void onUserPrepare() { /* compiled code */ }
&nbsp;
&nbsp;                protected void onUserStart() { /* compiled code */ }
&nbsp;
&nbsp;                protected void onUserReturn() { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                protected void onExitAdviceReturn() { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            protected static class WithoutExceptionHandling extends net.bytebuddy.asm.Advice.AdviceVisitor.WithExitAdvice {
&nbsp;                protected WithoutExceptionHandling(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter methodEnter, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit methodExit, int writerFlags, int readerFlags) { /* compiled code */ }
&nbsp;
&nbsp;                protected void onUserPrepare() { /* compiled code */ }
&nbsp;
&nbsp;                protected void onUserStart() { /* compiled code */ }
&nbsp;
&nbsp;                protected void onUserReturn() { /* compiled code */ }
&nbsp;
&nbsp;                protected void onExitAdviceReturn() { /* compiled code */ }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        protected static class WithoutExitAdvice extends net.bytebuddy.asm.Advice.AdviceVisitor {
&nbsp;            protected WithoutExitAdvice(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter methodEnter, int writerFlags, int readerFlags) { /* compiled code */ }
&nbsp;
&nbsp;            public void apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;            protected void onUserPrepare() { /* compiled code */ }
&nbsp;
&nbsp;            protected void onUserStart() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            protected void onUserEnd() { /* compiled code */ }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected static interface Dispatcher {
&nbsp;        @net.bytebuddy.utility.nullability.AlwaysNull
&nbsp;        net.bytebuddy.jar.asm.MethodVisitor IGNORE_METHOD;
<b class="nc">&nbsp;        @net.bytebuddy.utility.nullability.AlwaysNull</b>
&nbsp;        net.bytebuddy.jar.asm.AnnotationVisitor IGNORE_ANNOTATION;
&nbsp;
&nbsp;        boolean isAlive();
&nbsp;
&nbsp;        net.bytebuddy.description.type.TypeDefinition getAdviceType();
&nbsp;
<b class="nc">&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;        static class Delegating implements net.bytebuddy.asm.Advice.Dispatcher.Unresolved {
&nbsp;            protected final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;            protected final net.bytebuddy.asm.Advice.Delegator.Factory delegatorFactory;
&nbsp;
&nbsp;            protected Delegating(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.Delegator.Factory delegatorFactory) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean isAlive() { /* compiled code */ }
&nbsp;
&nbsp;            public boolean isBinary() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.description.type.TypeDescription getAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;            public java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; getNamedTypes() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter asMethodEnter(java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.asm.Advice.Dispatcher.Unresolved methodExit, net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit asMethodExit(java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.asm.Advice.Dispatcher.Unresolved methodEnter, net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory) { /* compiled code */ }
&nbsp;
&nbsp;            public java.lang.String toString() { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            protected static abstract class Resolved extends net.bytebuddy.asm.Advice.Dispatcher.Resolved.AbstractBase {
&nbsp;                protected final net.bytebuddy.asm.Advice.Delegator delegator;
&nbsp;
&nbsp;                protected Resolved(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; factories, net.bytebuddy.description.type.TypeDescription throwableType, net.bytebuddy.description.type.TypeDescription relocatableType, int relocatableIndex, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
&nbsp;
&nbsp;                public java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; getNamedTypes() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.Dispatcher.Bound bind(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                protected abstract net.bytebuddy.asm.Advice.Dispatcher.Bound resolve(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context context, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod forInstrumentedMethod, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod forInstrumentedMethod1, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod forInstrumentedMethod2, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation);</b>
<b class="fc">&nbsp;</b>
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static abstract class ForMethodExit extends net.bytebuddy.asm.Advice.Dispatcher.Delegating.Resolved implements net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit {
&nbsp;                    private final boolean backupArguments;
&nbsp;
&nbsp;                    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected ForMethodExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition enterType, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected static net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit of(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, net.bytebuddy.asm.Advice.Delegator delegator, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition enterType) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.asm.Advice.Dispatcher.Bound resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
&nbsp;                    private net.bytebuddy.asm.Advice.Dispatcher.Bound doResolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public net.bytebuddy.asm.Advice.ArgumentHandler.Factory getArgumentHandlerFactory() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public net.bytebuddy.description.type.TypeDefinition getAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                    protected static class WithoutExceptionHandler extends net.bytebuddy.asm.Advice.Dispatcher.Delegating.Resolved.ForMethodExit {
&nbsp;                        protected WithoutExceptionHandler(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition enterType, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.description.type.TypeDescription getThrowable() { /* compiled code */ }
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class WithExceptionHandler extends net.bytebuddy.asm.Advice.Dispatcher.Delegating.Resolved.ForMethodExit {
&nbsp;                        private final net.bytebuddy.description.type.TypeDescription throwable;
&nbsp;
&nbsp;                        protected WithExceptionHandler(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition enterType, net.bytebuddy.description.type.TypeDescription throwable, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.description.type.TypeDescription getThrowable() { /* compiled code */ }
&nbsp;
&nbsp;                        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                        public int hashCode() { /* compiled code */ }
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
<b class="fc">&nbsp;                protected static abstract class ForMethodEnter extends net.bytebuddy.asm.Advice.Dispatcher.Delegating.Resolved implements net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter {</b>
<b class="fc">&nbsp;                    private final boolean prependLineNumber;</b>
&nbsp;
&nbsp;                    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected ForMethodEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition exitType, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
&nbsp;
&nbsp;                    protected static net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter of(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, net.bytebuddy.asm.Advice.Delegator delegator, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition exitType, boolean methodExit) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                    public boolean isPrependLineNumber() { /* compiled code */ }</b>
&nbsp;
&nbsp;                    public net.bytebuddy.description.type.TypeDefinition getActualAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.asm.Advice.Dispatcher.Bound resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.asm.Advice.Dispatcher.Bound doResolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                    protected static class WithDiscardedEnterType extends net.bytebuddy.asm.Advice.Dispatcher.Delegating.Resolved.ForMethodEnter {
&nbsp;                        protected WithDiscardedEnterType(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition exitType, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.description.type.TypeDefinition getAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;                        protected net.bytebuddy.asm.Advice.Dispatcher.Bound doResolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class WithRetainedEnterType extends net.bytebuddy.asm.Advice.Dispatcher.Delegating.Resolved.ForMethodEnter {
&nbsp;                        protected WithRetainedEnterType(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition exitType, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                        public net.bytebuddy.description.type.TypeDefinition getAdviceType() { /* compiled code */ }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static abstract class AdviceMethodWriter implements net.bytebuddy.asm.Advice.Dispatcher.Bound {
&nbsp;                    protected final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
<b class="nc">&nbsp;                    private final net.bytebuddy.description.type.TypeDescription instrumentedType;</b>
&nbsp;                    private final net.bytebuddy.description.method.MethodDescription instrumentedMethod;
&nbsp;                    private final net.bytebuddy.implementation.bytecode.assign.Assigner assigner;
&nbsp;                    private final java.util.List&lt;net.bytebuddy.asm.Advice.OffsetMapping.Target&gt; offsetMappings;
&nbsp;                    protected final net.bytebuddy.jar.asm.MethodVisitor methodVisitor;
&nbsp;                    protected final net.bytebuddy.implementation.Implementation.Context implementationContext;
&nbsp;                    protected final net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler;
&nbsp;                    protected final net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler;
&nbsp;                    protected final net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler;
&nbsp;                    private final net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler;
&nbsp;                    private final net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler;
&nbsp;                    private final net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler;
&nbsp;                    private final net.bytebuddy.asm.Advice.PostProcessor postProcessor;
&nbsp;                    private final net.bytebuddy.asm.Advice.Delegator delegator;
&nbsp;
&nbsp;                    protected AdviceMethodWriter(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;net.bytebuddy.asm.Advice.OffsetMapping.Target&gt; offsetMappings, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
&nbsp;
&nbsp;                    public void prepare() { /* compiled code */ }
&nbsp;
&nbsp;                    public void apply() { /* compiled code */ }
&nbsp;
&nbsp;                    protected abstract boolean isExitAdvice();
&nbsp;
&nbsp;                    protected static class ForMethodExit extends net.bytebuddy.asm.Advice.Dispatcher.Delegating.Resolved.AdviceMethodWriter {
&nbsp;                        protected ForMethodExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;net.bytebuddy.asm.Advice.OffsetMapping.Target&gt; offsetMappings, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
&nbsp;
&nbsp;                        public void initialize() { /* compiled code */ }
&nbsp;
&nbsp;                        protected boolean isExitAdvice() { /* compiled code */ }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class ForMethodEnter extends net.bytebuddy.asm.Advice.Dispatcher.Delegating.Resolved.AdviceMethodWriter {
&nbsp;                        protected ForMethodEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;net.bytebuddy.asm.Advice.OffsetMapping.Target&gt; offsetMappings, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Delegator delegator) { /* compiled code */ }
&nbsp;
&nbsp;                        public void initialize() { /* compiled code */ }
&nbsp;
&nbsp;                        protected boolean isExitAdvice() { /* compiled code */ }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class Inlining implements net.bytebuddy.asm.Advice.Dispatcher.Unresolved {
&nbsp;            protected final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;            private final java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes;
&nbsp;
&nbsp;            protected Inlining(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean isAlive() { /* compiled code */ }
&nbsp;
&nbsp;            public boolean isBinary() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.description.type.TypeDescription getAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;            public java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; getNamedTypes() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter asMethodEnter(java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.asm.Advice.Dispatcher.Unresolved methodExit, net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit asMethodExit(java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.asm.Advice.Dispatcher.Unresolved methodEnter, net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory) { /* compiled code */ }
&nbsp;
&nbsp;            public java.lang.String toString() { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            protected static class CodeTranslationVisitor extends net.bytebuddy.jar.asm.MethodVisitor {
&nbsp;                protected final net.bytebuddy.jar.asm.MethodVisitor methodVisitor;
&nbsp;                protected final net.bytebuddy.implementation.Implementation.Context implementationContext;
&nbsp;                protected final net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler;
&nbsp;                protected final net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler;
&nbsp;                protected final net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler;
&nbsp;                private final net.bytebuddy.description.type.TypeDescription instrumentedType;
&nbsp;                private final net.bytebuddy.description.method.MethodDescription instrumentedMethod;
&nbsp;                private final net.bytebuddy.implementation.bytecode.assign.Assigner assigner;
&nbsp;                protected final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;                private final java.util.Map&lt;java.lang.Integer,net.bytebuddy.asm.Advice.OffsetMapping.Target&gt; offsetMappings;
&nbsp;                private final net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler;
&nbsp;                private final net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler;
&nbsp;                private final net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler;
&nbsp;                private final net.bytebuddy.asm.Advice.PostProcessor postProcessor;
&nbsp;                private final boolean exit;
&nbsp;                protected final net.bytebuddy.jar.asm.Label endOfMethod;
&nbsp;
&nbsp;                protected CodeTranslationVisitor(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, java.util.Map&lt;java.lang.Integer,net.bytebuddy.asm.Advice.OffsetMapping.Target&gt; offsetMappings, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.PostProcessor postProcessor, boolean exit) { /* compiled code */ }
&nbsp;
&nbsp;                protected void propagateHandler(net.bytebuddy.jar.asm.Label label) { /* compiled code */ }
&nbsp;
&nbsp;                public void visitParameter(java.lang.String name, int modifiers) { /* compiled code */ }
&nbsp;
&nbsp;                public void visitAnnotableParameterCount(int count, boolean visible) { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.utility.nullability.MaybeNull
&nbsp;                public net.bytebuddy.jar.asm.AnnotationVisitor visitAnnotationDefault() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.utility.nullability.MaybeNull
&nbsp;                public net.bytebuddy.jar.asm.AnnotationVisitor visitAnnotation(java.lang.String descriptor, boolean visible) { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.utility.nullability.MaybeNull
&nbsp;                public net.bytebuddy.jar.asm.AnnotationVisitor visitTypeAnnotation(int typeReference, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.TypePath typePath, java.lang.String descriptor, boolean visible) { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.utility.nullability.MaybeNull
&nbsp;                public net.bytebuddy.jar.asm.AnnotationVisitor visitParameterAnnotation(int index, java.lang.String descriptor, boolean visible) { /* compiled code */ }
&nbsp;
&nbsp;                public void visitAttribute(net.bytebuddy.jar.asm.Attribute attribute) { /* compiled code */ }
&nbsp;
&nbsp;                public void visitCode() { /* compiled code */ }
&nbsp;
&nbsp;                public void visitFrame(int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }
&nbsp;
&nbsp;                public void visitVarInsn(int opcode, int offset) { /* compiled code */ }
&nbsp;
&nbsp;                public void visitIincInsn(int offset, int value) { /* compiled code */ }
&nbsp;
&nbsp;                public void visitInsn(int opcode) { /* compiled code */ }
&nbsp;
&nbsp;                public void visitEnd() { /* compiled code */ }
&nbsp;
&nbsp;                public void visitMaxs(int stackSize, int localVariableLength) { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            protected static abstract class Resolved extends net.bytebuddy.asm.Advice.Dispatcher.Resolved.AbstractBase {
&nbsp;                protected final net.bytebuddy.jar.asm.ClassReader classReader;
&nbsp;
&nbsp;                protected Resolved(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; factories, net.bytebuddy.description.type.TypeDescription throwableType, net.bytebuddy.description.type.TypeDescription relocatableType, int relocatableIndex, net.bytebuddy.jar.asm.ClassReader classReader) { /* compiled code */ }
&nbsp;
&nbsp;                protected abstract java.util.Map&lt;java.lang.Integer,net.bytebuddy.description.type.TypeDefinition&gt; resolveInitializationTypes(net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler);
&nbsp;
&nbsp;                protected abstract net.bytebuddy.jar.asm.MethodVisitor apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context context, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod forInstrumentedMethod, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod forInstrumentedMethod1, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod forInstrumentedMethod2, net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound bound, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound bound1, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation);
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static abstract class ForMethodExit extends net.bytebuddy.asm.Advice.Dispatcher.Inlining.Resolved implements net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit {
&nbsp;                    private final java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; uninitializedNamedTypes;
&nbsp;                    private final boolean backupArguments;
&nbsp;
&nbsp;                    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected ForMethodExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; uninitializedNamedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.description.type.TypeDefinition enterType) { /* compiled code */ }
&nbsp;
&nbsp;                    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected static net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit of(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; uninitializedNamedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.description.type.TypeDefinition enterType) { /* compiled code */ }
&nbsp;
&nbsp;                    public java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; getNamedTypes() { /* compiled code */ }
&nbsp;
&nbsp;                    protected java.util.Map&lt;java.lang.Integer,net.bytebuddy.description.type.TypeDefinition&gt; resolveInitializationTypes(net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.jar.asm.MethodVisitor apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;                    private net.bytebuddy.jar.asm.MethodVisitor doApply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.ArgumentHandler.Factory getArgumentHandlerFactory() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.description.type.TypeDefinition getAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.Dispatcher.Bound bind(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                    protected static class WithoutExceptionHandler extends net.bytebuddy.asm.Advice.Dispatcher.Inlining.Resolved.ForMethodExit {
&nbsp;                        protected WithoutExceptionHandler(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; uninitializedNamedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.description.type.TypeDefinition enterType) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.description.type.TypeDescription getThrowable() { /* compiled code */ }
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class WithExceptionHandler extends net.bytebuddy.asm.Advice.Dispatcher.Inlining.Resolved.ForMethodExit {
&nbsp;                        private final net.bytebuddy.description.type.TypeDescription throwable;
&nbsp;
&nbsp;                        protected WithExceptionHandler(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; uninitializedNamedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.description.type.TypeDefinition enterType, net.bytebuddy.description.type.TypeDescription throwable) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.description.type.TypeDescription getThrowable() { /* compiled code */ }
&nbsp;
&nbsp;                        public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                        public int hashCode() { /* compiled code */ }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static abstract class ForMethodEnter extends net.bytebuddy.asm.Advice.Dispatcher.Inlining.Resolved implements net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter {
&nbsp;                    private final java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes;
&nbsp;                    private final boolean prependLineNumber;
&nbsp;
&nbsp;                    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected ForMethodEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition exitType, net.bytebuddy.jar.asm.ClassReader classReader) { /* compiled code */ }
&nbsp;
&nbsp;                    protected static net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter of(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition exitType, net.bytebuddy.jar.asm.ClassReader classReader, boolean methodExit) { /* compiled code */ }
&nbsp;
&nbsp;                    protected java.util.Map&lt;java.lang.Integer,net.bytebuddy.description.type.TypeDefinition&gt; resolveInitializationTypes(net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.Dispatcher.Bound bind(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean isPrependLineNumber() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.description.type.TypeDefinition getActualAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; getNamedTypes() { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.jar.asm.MethodVisitor apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.jar.asm.MethodVisitor doApply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                    protected static class WithDiscardedEnterType extends net.bytebuddy.asm.Advice.Dispatcher.Inlining.Resolved.ForMethodEnter {
&nbsp;                        protected WithDiscardedEnterType(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition exitType, net.bytebuddy.jar.asm.ClassReader classReader) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.description.type.TypeDefinition getAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;                        protected net.bytebuddy.jar.asm.MethodVisitor doApply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class WithRetainedEnterType extends net.bytebuddy.asm.Advice.Dispatcher.Inlining.Resolved.ForMethodEnter {
&nbsp;                        protected WithRetainedEnterType(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, net.bytebuddy.description.type.TypeDefinition exitType, net.bytebuddy.jar.asm.ClassReader classReader) { /* compiled code */ }
&nbsp;
&nbsp;                        public net.bytebuddy.description.type.TypeDefinition getAdviceType() { /* compiled code */ }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected class AdviceMethodInliner extends net.bytebuddy.jar.asm.ClassVisitor implements net.bytebuddy.asm.Advice.Dispatcher.Bound {
&nbsp;                    protected final net.bytebuddy.description.type.TypeDescription instrumentedType;
&nbsp;                    protected final net.bytebuddy.description.method.MethodDescription instrumentedMethod;
&nbsp;                    protected final net.bytebuddy.jar.asm.MethodVisitor methodVisitor;
&nbsp;                    protected final net.bytebuddy.implementation.Implementation.Context implementationContext;
&nbsp;                    protected final net.bytebuddy.implementation.bytecode.assign.Assigner assigner;
&nbsp;                    protected final net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler;
&nbsp;                    protected final net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler;
&nbsp;                    protected final net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler;
&nbsp;                    protected final net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler;
&nbsp;                    protected final net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler;
&nbsp;                    protected final net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler;
&nbsp;                    protected final net.bytebuddy.jar.asm.ClassReader classReader;
&nbsp;                    protected final java.util.List&lt;net.bytebuddy.jar.asm.Label&gt; labels;
&nbsp;
&nbsp;                    protected AdviceMethodInliner(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound suppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound relocationHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.jar.asm.ClassReader classReader) { /* compiled code */ }
&nbsp;
&nbsp;                    public void prepare() { /* compiled code */ }
&nbsp;
&nbsp;                    public void initialize() { /* compiled code */ }
&nbsp;
&nbsp;                    public void apply() { /* compiled code */ }
&nbsp;
&nbsp;                    @net.bytebuddy.utility.nullability.MaybeNull
&nbsp;                    public net.bytebuddy.jar.asm.MethodVisitor visitMethod(int modifiers, java.lang.String internalName, java.lang.String descriptor, @net.bytebuddy.utility.nullability.MaybeNull java.lang.String signature, @net.bytebuddy.utility.nullability.MaybeNull java.lang.String[] exception) { /* compiled code */ }
&nbsp;
&nbsp;                    protected class ExceptionTableSubstitutor extends net.bytebuddy.jar.asm.MethodVisitor {
&nbsp;                        private final java.util.Map&lt;net.bytebuddy.jar.asm.Label,net.bytebuddy.jar.asm.Label&gt; substitutions;
<b class="fc">&nbsp;                        private int index;</b>
<b class="fc">&nbsp;</b>
&nbsp;                        protected ExceptionTableSubstitutor(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                        public void visitTryCatchBlock(net.bytebuddy.jar.asm.Label start, net.bytebuddy.jar.asm.Label end, net.bytebuddy.jar.asm.Label handler, java.lang.String type) { /* compiled code */ }
&nbsp;
&nbsp;                        @net.bytebuddy.utility.nullability.MaybeNull
&nbsp;                        public net.bytebuddy.jar.asm.AnnotationVisitor visitTryCatchAnnotation(int typeReference, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.TypePath typePath, java.lang.String descriptor, boolean visible) { /* compiled code */ }
&nbsp;
&nbsp;                        public void visitLabel(net.bytebuddy.jar.asm.Label label) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                        public void visitJumpInsn(int opcode, net.bytebuddy.jar.asm.Label label) { /* compiled code */ }</b>
&nbsp;
&nbsp;                        public void visitTableSwitchInsn(int minimum, int maximum, net.bytebuddy.jar.asm.Label defaultOption, net.bytebuddy.jar.asm.Label... label) { /* compiled code */ }
&nbsp;
&nbsp;                        public void visitLookupSwitchInsn(net.bytebuddy.jar.asm.Label defaultOption, int[] keys, net.bytebuddy.jar.asm.Label[] label) { /* compiled code */ }
&nbsp;
&nbsp;                        private net.bytebuddy.jar.asm.Label[] resolve(net.bytebuddy.jar.asm.Label[] label) { /* compiled code */ }
&nbsp;
&nbsp;                        private net.bytebuddy.jar.asm.Label resolve(net.bytebuddy.jar.asm.Label label) { /* compiled code */ }
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                    protected class ExceptionTableCollector extends net.bytebuddy.jar.asm.MethodVisitor {
&nbsp;                        private final net.bytebuddy.jar.asm.MethodVisitor methodVisitor;
&nbsp;
&nbsp;                        protected ExceptionTableCollector(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                        public void visitTryCatchBlock(net.bytebuddy.jar.asm.Label start, net.bytebuddy.jar.asm.Label end, net.bytebuddy.jar.asm.Label handler, @net.bytebuddy.utility.nullability.MaybeNull java.lang.String type) { /* compiled code */ }
&nbsp;
&nbsp;                        @net.bytebuddy.utility.nullability.MaybeNull
&nbsp;                        public net.bytebuddy.jar.asm.AnnotationVisitor visitTryCatchAnnotation(int typeReference, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.TypePath typePath, java.lang.String descriptor, boolean visible) { /* compiled code */ }
<b class="nc">&nbsp;                    }</b>
&nbsp;
<b class="nc">&nbsp;                    protected class ExceptionTableExtractor extends net.bytebuddy.jar.asm.ClassVisitor {</b>
&nbsp;                        protected ExceptionTableExtractor() { /* compiled code */ }
&nbsp;
&nbsp;                        @net.bytebuddy.utility.nullability.MaybeNull
&nbsp;                        public net.bytebuddy.jar.asm.MethodVisitor visitMethod(int modifiers, java.lang.String internalName, java.lang.String descriptor, @net.bytebuddy.utility.nullability.MaybeNull java.lang.String signature, @net.bytebuddy.utility.nullability.MaybeNull java.lang.String[] exception) { /* compiled code */ }
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        static enum Inactive implements net.bytebuddy.asm.Advice.Dispatcher.Unresolved, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter, net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit, net.bytebuddy.asm.Advice.Dispatcher.Bound {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Inactive() { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;            public boolean isAlive() { /* compiled code */ }
&nbsp;
&nbsp;            public boolean isBinary() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.description.type.TypeDescription getAdviceType() { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;            public boolean isPrependLineNumber() { /* compiled code */ }</b>
&nbsp;
&nbsp;            public net.bytebuddy.description.type.TypeDefinition getActualAdviceType() { /* compiled code */ }
&nbsp;
&nbsp;            public java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; getNamedTypes() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.description.type.TypeDescription getThrowable() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.ArgumentHandler.Factory getArgumentHandlerFactory() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter asMethodEnter(java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.asm.Advice.Dispatcher.Unresolved methodExit, net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit asMethodExit(java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.asm.Advice.Dispatcher.Unresolved methodEnter, net.bytebuddy.asm.Advice.PostProcessor.Factory postProcessorFactory) { /* compiled code */ }
&nbsp;
&nbsp;            public void prepare() { /* compiled code */ }
&nbsp;
&nbsp;            public void initialize() { /* compiled code */ }
&nbsp;
&nbsp;            public void apply() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.Dispatcher.Bound bind(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod argumentHandler, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        static interface Bound {
&nbsp;            void prepare();
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            void initialize();</b>
<b class="nc">&nbsp;</b>
&nbsp;            void apply();
&nbsp;        }
&nbsp;
&nbsp;        static interface Resolved extends net.bytebuddy.asm.Advice.Dispatcher {
&nbsp;            java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; getNamedTypes();
&nbsp;
<b class="nc">&nbsp;            net.bytebuddy.asm.Advice.Dispatcher.Bound bind(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context context, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod forInstrumentedMethod, net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod forInstrumentedMethod1, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod forInstrumentedMethod2, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation);</b>
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static abstract class AbstractBase implements net.bytebuddy.asm.Advice.Dispatcher.Resolved {
&nbsp;                protected final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;                protected final net.bytebuddy.asm.Advice.PostProcessor postProcessor;
&nbsp;                protected final java.util.Map&lt;java.lang.Integer,net.bytebuddy.asm.Advice.OffsetMapping&gt; offsetMappings;
<b class="nc">&nbsp;                protected final net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler suppressionHandler;</b>
&nbsp;                protected final net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler relocationHandler;
&nbsp;
&nbsp;                protected AbstractBase(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.PostProcessor postProcessor, java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; factories, net.bytebuddy.description.type.TypeDescription throwableType, net.bytebuddy.description.type.TypeDescription relocatableType, int relocatableIndex, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean isAlive() { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            static interface ForMethodExit extends net.bytebuddy.asm.Advice.Dispatcher.Resolved {
&nbsp;                net.bytebuddy.description.type.TypeDescription getThrowable();
&nbsp;
&nbsp;                net.bytebuddy.asm.Advice.ArgumentHandler.Factory getArgumentHandlerFactory();
&nbsp;            }
&nbsp;
&nbsp;            static interface ForMethodEnter extends net.bytebuddy.asm.Advice.Dispatcher.Resolved {
&nbsp;                boolean isPrependLineNumber();
&nbsp;
&nbsp;                net.bytebuddy.description.type.TypeDefinition getActualAdviceType();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static interface RelocationHandler {
&nbsp;            net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound bind(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation);
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class ForType implements net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler {
&nbsp;                private final net.bytebuddy.description.type.TypeDescription typeDescription;
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForType(net.bytebuddy.description.type.TypeDescription typeDescription, int index) { /* compiled code */ }
&nbsp;
&nbsp;                @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                protected static net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler of(net.bytebuddy.description.type.TypeDescription typeDescription, int index, net.bytebuddy.description.type.TypeDefinition returnedType) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound bind(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                protected class Bound implements net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound {</b>
&nbsp;                    private final net.bytebuddy.description.method.MethodDescription instrumentedMethod;
&nbsp;                    private final net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation;
&nbsp;
&nbsp;                    protected Bound(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                    public int apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, int offset) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            static abstract enum ForValue {
&nbsp;                BOOLEAN, BYTE, SHORT, CHARACTER, INTEGER, LONG, FLOAT, DOUBLE, REFERENCE;
&nbsp;
<b class="fc">&nbsp;                private final int load;</b>
<b class="fc">&nbsp;                private final int arrayLoad;</b>
&nbsp;                private final int defaultJump;
&nbsp;                private final int nonDefaultJump;
&nbsp;                private final int requiredSize;
&nbsp;
&nbsp;                private ForValue(int load, int arrayLoad, int defaultJump, int nonDefaultJump, int requiredSize) { /* compiled code */ }
&nbsp;
&nbsp;                protected static net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler of(net.bytebuddy.description.type.TypeDefinition typeDefinition, int index, boolean inverted) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                protected abstract void convertValue(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);</b>
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class Bound implements net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound {
&nbsp;                    private final net.bytebuddy.description.method.MethodDescription instrumentedMethod;
&nbsp;                    private final net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation;
&nbsp;                    private final int index;
&nbsp;                    private final boolean inverted;
&nbsp;
&nbsp;                    protected Bound(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation, int index, boolean inverted) { /* compiled code */ }
&nbsp;
&nbsp;                    public int apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, int offset) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class OfNonDefault implements net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler {
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    protected OfNonDefault(int index) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound bind(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class OfDefault implements net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler {
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    public OfDefault(int index) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound bind(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            static enum Disabled implements net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Disabled() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Bound bind(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation relocation) { /* compiled code */ }
&nbsp;
&nbsp;                public int apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, int offset) { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            static interface Bound {
&nbsp;                int NO_REQUIRED_SIZE = 0;
&nbsp;
&nbsp;                int apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context context, int i);
&nbsp;            }
&nbsp;
&nbsp;            static interface Relocation {
&nbsp;                void apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                static class ForLabel implements net.bytebuddy.asm.Advice.Dispatcher.RelocationHandler.Relocation {
<b class="fc">&nbsp;                    private final net.bytebuddy.jar.asm.Label label;</b>
<b class="fc">&nbsp;</b>
&nbsp;                    public ForLabel(net.bytebuddy.jar.asm.Label label) { /* compiled code */ }
&nbsp;
&nbsp;                    public void apply(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                    public int hashCode() { /* compiled code */ }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static interface SuppressionHandler {
&nbsp;            net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound bind(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation);
<b class="nc">&nbsp;</b>
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Suppressing implements net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler {
&nbsp;                private final net.bytebuddy.description.type.TypeDescription suppressedType;
&nbsp;
&nbsp;                protected Suppressing(net.bytebuddy.description.type.TypeDescription suppressedType) { /* compiled code */ }
&nbsp;
&nbsp;                protected static net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler of(net.bytebuddy.description.type.TypeDescription suppressedType) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                public net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound bind(net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                public int hashCode() { /* compiled code */ }</b>
&nbsp;
&nbsp;                protected static class Bound implements net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound {
<b class="fc">&nbsp;                    private final net.bytebuddy.description.type.TypeDescription suppressedType;</b>
&nbsp;                    private final net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler;
&nbsp;                    private final net.bytebuddy.jar.asm.Label startOfMethod;
&nbsp;                    private final net.bytebuddy.jar.asm.Label endOfMethod;
&nbsp;
&nbsp;                    protected Bound(net.bytebuddy.description.type.TypeDescription suppressedType, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                    public void onPrepare(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }</b>
&nbsp;
&nbsp;                    public void onStart(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                    public void onEnd(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.description.type.TypeDefinition returnType) { /* compiled code */ }
&nbsp;
&nbsp;                    public void onEndWithSkip(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.description.type.TypeDefinition returnType) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            static enum NoOp implements net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler, net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private NoOp() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.Dispatcher.SuppressionHandler.Bound bind(net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;                public void onPrepare(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void onStart(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void onEnd(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.description.type.TypeDefinition returnType) { /* compiled code */ }
&nbsp;
&nbsp;                public void onEndWithSkip(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context implementationContext, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice methodSizeHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice stackMapFrameHandler, net.bytebuddy.description.type.TypeDefinition returnType) { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            static interface Bound {
&nbsp;                void onPrepare(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
&nbsp;                void onStart(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
&nbsp;                void onEnd(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context context, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice forAdvice, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice forAdvice1, net.bytebuddy.description.type.TypeDefinition typeDefinition);
&nbsp;
&nbsp;                void onEndWithSkip(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.implementation.Implementation.Context context, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice forAdvice, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice forAdvice1, net.bytebuddy.description.type.TypeDefinition typeDefinition);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static interface Unresolved extends net.bytebuddy.asm.Advice.Dispatcher {
&nbsp;            boolean isBinary();
&nbsp;
&nbsp;            java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; getNamedTypes();
&nbsp;
&nbsp;            net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodEnter asMethodEnter(java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; list, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.asm.Advice.Dispatcher.Unresolved unresolved, net.bytebuddy.asm.Advice.PostProcessor.Factory factory);
&nbsp;
&nbsp;            net.bytebuddy.asm.Advice.Dispatcher.Resolved.ForMethodExit asMethodExit(java.util.List&lt;? extends net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt;&gt; list, @net.bytebuddy.utility.nullability.MaybeNull net.bytebuddy.jar.asm.ClassReader classReader, net.bytebuddy.asm.Advice.Dispatcher.Unresolved unresolved, net.bytebuddy.asm.Advice.PostProcessor.Factory factory);
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public static interface ExceptionHandler {</b>
&nbsp;        net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.description.type.TypeDescription typeDescription);
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class Simple implements net.bytebuddy.asm.Advice.ExceptionHandler {
&nbsp;            private final net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation;
&nbsp;
&nbsp;            public Simple(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.description.type.TypeDescription instrumentedType) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public int hashCode() { /* compiled code */ }</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        static abstract enum Default implements net.bytebuddy.asm.Advice.ExceptionHandler {</b>
&nbsp;            SUPPRESSING, PRINTING, RETHROWING;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            private Default() { /* compiled code */ }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public static interface StackMapFrameHandler {
&nbsp;        void translateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, int i, int i1, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] objects, int i2, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] objects1);
&nbsp;
&nbsp;        void injectReturnFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
&nbsp;        void injectExceptionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
&nbsp;        void injectCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
&nbsp;        static abstract class Default implements net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod {
&nbsp;            protected static final java.lang.Object[] EMPTY;
&nbsp;            protected final net.bytebuddy.description.type.TypeDescription instrumentedType;
&nbsp;            protected final net.bytebuddy.description.method.MethodDescription instrumentedMethod;
&nbsp;            protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes;
&nbsp;            protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; latentTypes;
&nbsp;            protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes;
&nbsp;            protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes;
&nbsp;            protected final boolean expandFrames;
&nbsp;            protected int currentFrameDivergence;
&nbsp;
&nbsp;            protected Default(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; latentTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes, boolean expandFrames) { /* compiled code */ }
&nbsp;
&nbsp;            protected static net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod of(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; latentTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes, boolean exitAdvice, boolean copyArguments, net.bytebuddy.ClassFileVersion classFileVersion, int writerFlags, int readerFlags) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice bindEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;            public int getReaderHint() { /* compiled code */ }
&nbsp;
&nbsp;            protected void translateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.TranslationMode translationMode, net.bytebuddy.description.method.MethodDescription methodDescription, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; additionalTypes, int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }
&nbsp;
&nbsp;            protected void injectFullFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.Initialization initialization, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; typesInArray, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; typesOnStack) { /* compiled code */ }
&nbsp;
&nbsp;            protected class ForAdvice implements net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice {
&nbsp;                protected final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;                protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; startTypes;
<b class="fc">&nbsp;                private final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; intermediateTypes;</b>
<b class="fc">&nbsp;                protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; endTypes;</b>
<b class="fc">&nbsp;                protected final net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.TranslationMode translationMode;</b>
<b class="fc">&nbsp;                private final net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.Initialization initialization;</b>
&nbsp;                private boolean intermedate;
&nbsp;
&nbsp;                protected ForAdvice(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; startTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; intermediateTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; endTypes, net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.TranslationMode translationMode, net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.Initialization initialization) { /* compiled code */ }
&nbsp;
&nbsp;                public void translateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectReturnFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                public void injectExceptionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }</b>
&nbsp;
&nbsp;                public void injectCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectIntermediateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; stack) { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            protected static abstract class WithPreservedArguments extends net.bytebuddy.asm.Advice.StackMapFrameHandler.Default {
&nbsp;                protected boolean allowCompactCompletionFrame;
&nbsp;
&nbsp;                protected WithPreservedArguments(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; latentTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes, boolean expandFrames, boolean allowCompactCompletionFrame) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;RC_REF_COMPARISON_BAD_PRACTICE&quot;}, justification = &quot;ASM models frames by reference identity.&quot;)</b>
&nbsp;                protected void translateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.TranslationMode translationMode, net.bytebuddy.description.method.MethodDescription methodDescription, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; additionalTypes, int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectReturnFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectExceptionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectPostCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                public void injectInitializationFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected static class WithArgumentCopy extends net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.WithPreservedArguments {</b>
&nbsp;                    protected WithArgumentCopy(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; latentTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes, boolean expandFrames) { /* compiled code */ }
&nbsp;
&nbsp;                    public void injectStartFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;RC_REF_COMPARISON_BAD_PRACTICE&quot;}, justification = &quot;ASM models frames by reference identity.&quot;)</b>
<b class="fc">&nbsp;                    public void translateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="fc">&nbsp;                protected static class WithoutArgumentCopy extends net.bytebuddy.asm.Advice.StackMapFrameHandler.Default.WithPreservedArguments {</b>
&nbsp;                    protected WithoutArgumentCopy(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; latentTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes, boolean expandFrames, boolean allowCompactCompletionFrame) { /* compiled code */ }
&nbsp;
&nbsp;                    public void injectStartFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                    public void translateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class Trivial extends net.bytebuddy.asm.Advice.StackMapFrameHandler.Default {
&nbsp;                protected Trivial(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; latentTypes, boolean expandFrames) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                public void translateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectReturnFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                public void injectExceptionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectPostCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                public void injectInitializationFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                public void injectStartFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            protected static abstract enum Initialization {
&nbsp;                UNITIALIZED, INITIALIZED;
&nbsp;
&nbsp;                private Initialization() { /* compiled code */ }
&nbsp;
&nbsp;                protected abstract java.lang.Object toFrame(net.bytebuddy.description.type.TypeDescription typeDescription);
&nbsp;            }
&nbsp;
&nbsp;            protected static abstract enum TranslationMode {
&nbsp;                COPY, ENTER, EXIT;
&nbsp;
&nbsp;                private TranslationMode() { /* compiled code */ }
&nbsp;
&nbsp;                protected abstract int copy(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.description.method.MethodDescription methodDescription1, java.lang.Object[] objects, java.lang.Object[] objects1);
&nbsp;
&nbsp;                protected abstract boolean isPossibleThisFrameValue(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription, java.lang.Object o);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static enum NoOp implements net.bytebuddy.asm.Advice.StackMapFrameHandler.ForInstrumentedMethod, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private NoOp() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice bindEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public int getReaderHint() { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public void translateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, int type, int localVariableLength, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] localVariable, int stackSize, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object[] stack) { /* compiled code */ }
&nbsp;
&nbsp;            public void injectReturnFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;            public void injectExceptionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            public void injectCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public void injectInitializationFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;            public void injectStartFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;            public void injectPostCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;            public void injectIntermediateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; stack) { /* compiled code */ }
<b class="fc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        static interface ForAdvice extends net.bytebuddy.asm.Advice.StackMapFrameHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor {
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        static interface ForInstrumentedMethod extends net.bytebuddy.asm.Advice.StackMapFrameHandler {
&nbsp;            net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice bindEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape);
&nbsp;
&nbsp;            net.bytebuddy.asm.Advice.StackMapFrameHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape);
&nbsp;
&nbsp;            int getReaderHint();
&nbsp;
&nbsp;            void injectInitializationFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
&nbsp;            void injectStartFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
&nbsp;            void injectPostCompletionFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;        }
&nbsp;
&nbsp;        static interface ForPostProcessor {
&nbsp;            void injectIntermediateFrame(net.bytebuddy.jar.asm.MethodVisitor methodVisitor, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; list);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected static interface MethodSizeHandler {
&nbsp;        int UNDEFINED_SIZE = 32767;
&nbsp;
&nbsp;        void requireStackSize(int i);
&nbsp;
&nbsp;        void requireLocalVariableLength(int i);
&nbsp;
&nbsp;        static abstract class Default implements net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod {
&nbsp;            protected final net.bytebuddy.description.method.MethodDescription instrumentedMethod;
&nbsp;            protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes;
&nbsp;            protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes;
&nbsp;            protected final java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes;
&nbsp;            protected int stackSize;
&nbsp;            protected int localVariableLength;
&nbsp;
&nbsp;            protected Default(net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes) { /* compiled code */ }
&nbsp;
&nbsp;            protected static net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod of(net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes, boolean copyArguments, int writerFlags) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice bindEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;            public void requireStackSize(int stackSize) { /* compiled code */ }
&nbsp;
&nbsp;            public void requireLocalVariableLength(int localVariableLength) { /* compiled code */ }
&nbsp;
&nbsp;            public int compoundStackSize(int stackSize) { /* compiled code */ }
&nbsp;
&nbsp;            public int compoundLocalVariableLength(int localVariableLength) { /* compiled code */ }
&nbsp;
&nbsp;            protected class ForAdvice implements net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice {
&nbsp;                private final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;                private final int baseLocalVariableLength;
&nbsp;                private int stackSizePadding;
&nbsp;                private int localVariableLengthPadding;
&nbsp;
&nbsp;                protected ForAdvice(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, int baseLocalVariableLength) { /* compiled code */ }
&nbsp;
&nbsp;                public void requireStackSize(int stackSize) { /* compiled code */ }
&nbsp;
&nbsp;                public void requireLocalVariableLength(int localVariableLength) { /* compiled code */ }
&nbsp;
&nbsp;                public void requireStackSizePadding(int stackSizePadding) { /* compiled code */ }
&nbsp;
&nbsp;                public void requireLocalVariableLengthPadding(int localVariableLengthPadding) { /* compiled code */ }
&nbsp;
&nbsp;                public void recordMaxima(int stackSize, int localVariableLength) { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            protected static class WithCopiedArguments extends net.bytebuddy.asm.Advice.MethodSizeHandler.Default {
&nbsp;                protected WithCopiedArguments(net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;                public int compoundLocalVariableLength(int localVariableLength) { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            protected static class WithRetainedArguments extends net.bytebuddy.asm.Advice.MethodSizeHandler.Default {
&nbsp;                protected WithRetainedArguments(net.bytebuddy.description.method.MethodDescription instrumentedMethod, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; initialTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; preMethodTypes, java.util.List&lt;? extends net.bytebuddy.description.type.TypeDescription&gt; postMethodTypes) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;                public int compoundLocalVariableLength(int localVariableLength) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static enum NoOp implements net.bytebuddy.asm.Advice.MethodSizeHandler.ForInstrumentedMethod, net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private NoOp() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice bindEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
&nbsp;            public int compoundStackSize(int stackSize) { /* compiled code */ }
&nbsp;
&nbsp;            public int compoundLocalVariableLength(int localVariableLength) { /* compiled code */ }
&nbsp;
&nbsp;            public void requireStackSize(int stackSize) { /* compiled code */ }
&nbsp;
&nbsp;            public void requireLocalVariableLength(int localVariableLength) { /* compiled code */ }
&nbsp;
&nbsp;            public void requireStackSizePadding(int stackSizePadding) { /* compiled code */ }
&nbsp;
&nbsp;            public void requireLocalVariableLengthPadding(int localVariableLengthPadding) { /* compiled code */ }
&nbsp;
&nbsp;            public void recordMaxima(int stackSize, int localVariableLength) { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        static interface ForAdvice extends net.bytebuddy.asm.Advice.MethodSizeHandler {
&nbsp;            void requireStackSizePadding(int i);
&nbsp;
&nbsp;            void requireLocalVariableLengthPadding(int i);
&nbsp;
&nbsp;            void recordMaxima(int i, int i1);
&nbsp;        }
&nbsp;
&nbsp;        static interface ForInstrumentedMethod extends net.bytebuddy.asm.Advice.MethodSizeHandler {
&nbsp;            net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice bindEnter(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape);
&nbsp;
&nbsp;            net.bytebuddy.asm.Advice.MethodSizeHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape);
&nbsp;
&nbsp;            int compoundStackSize(int i);
&nbsp;
&nbsp;            int compoundLocalVariableLength(int i);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static interface BootstrapArgumentResolver {
&nbsp;        java.util.List&lt;net.bytebuddy.utility.JavaConstant&gt; resolve(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription);
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForDefaultValues implements net.bytebuddy.asm.Advice.BootstrapArgumentResolver {
&nbsp;            private final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;            private final boolean exit;
&nbsp;
&nbsp;            protected ForDefaultValues(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, boolean exit) { /* compiled code */ }
&nbsp;
&nbsp;            public java.util.List&lt;net.bytebuddy.utility.JavaConstant&gt; resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            public int hashCode() { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public static enum Factory implements net.bytebuddy.asm.Advice.BootstrapArgumentResolver.Factory {</b>
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.BootstrapArgumentResolver resolve(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, boolean exit) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static interface Factory {
&nbsp;            net.bytebuddy.asm.Advice.BootstrapArgumentResolver resolve(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape, boolean b);
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    protected static interface Delegator {</b>
<b class="fc">&nbsp;        net.bytebuddy.implementation.bytecode.StackManipulation apply(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription);</b>
<b class="fc">&nbsp;</b>
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForDynamicInvocation implements net.bytebuddy.asm.Advice.Delegator {
&nbsp;            private final net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;            private final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;            private final net.bytebuddy.asm.Advice.BootstrapArgumentResolver resolver;
&nbsp;
&nbsp;            protected ForDynamicInvocation(net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod, net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, net.bytebuddy.asm.Advice.BootstrapArgumentResolver resolver) { /* compiled code */ }
&nbsp;
&nbsp;            protected static net.bytebuddy.asm.Advice.Delegator.Factory of(net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod, net.bytebuddy.asm.Advice.BootstrapArgumentResolver.Factory resolverFactory) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            public net.bytebuddy.implementation.bytecode.StackManipulation apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;            protected static class Factory implements net.bytebuddy.asm.Advice.Delegator.Factory {
&nbsp;                private final net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod;
<b class="fc">&nbsp;                private final net.bytebuddy.asm.Advice.BootstrapArgumentResolver.Factory resolverFactory;</b>
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;                protected Factory(net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod, net.bytebuddy.asm.Advice.BootstrapArgumentResolver.Factory resolverFactory) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public net.bytebuddy.asm.Advice.Delegator make(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, boolean exit) { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public int hashCode() { /* compiled code */ }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForRegularInvocation implements net.bytebuddy.asm.Advice.Delegator {
&nbsp;            private final net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;            protected ForRegularInvocation(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            public net.bytebuddy.implementation.bytecode.StackManipulation apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;            protected static enum Factory implements net.bytebuddy.asm.Advice.Delegator.Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.Delegator make(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod, boolean exit) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static interface Factory {
&nbsp;            net.bytebuddy.asm.Advice.Delegator make(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape, boolean b);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static interface PostProcessor {
&nbsp;        net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor forPostProcessor, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation);
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class Compound implements net.bytebuddy.asm.Advice.PostProcessor {
&nbsp;            private final java.util.List&lt;net.bytebuddy.asm.Advice.PostProcessor&gt; postProcessors;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            protected Compound(java.util.List&lt;net.bytebuddy.asm.Advice.PostProcessor&gt; postProcessors) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        static enum NoOp implements net.bytebuddy.asm.Advice.PostProcessor, net.bytebuddy.asm.Advice.PostProcessor.Factory {</b>
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private NoOp() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.implementation.bytecode.StackManipulation resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, net.bytebuddy.implementation.bytecode.StackManipulation exceptionHandler) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.PostProcessor make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit) { /* compiled code */ }
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;        static interface Factory {</b>
&nbsp;            net.bytebuddy.asm.Advice.PostProcessor make(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape, boolean b);
<b class="fc">&nbsp;</b>
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Compound implements net.bytebuddy.asm.Advice.PostProcessor.Factory {
&nbsp;                private final java.util.List&lt;net.bytebuddy.asm.Advice.PostProcessor.Factory&gt; factories;
&nbsp;
&nbsp;                public Compound(net.bytebuddy.asm.Advice.PostProcessor.Factory... factory) { /* compiled code */ }
&nbsp;
&nbsp;                public Compound(java.util.List&lt;? extends net.bytebuddy.asm.Advice.PostProcessor.Factory&gt; factories) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.PostProcessor make(net.bytebuddy.description.method.MethodDescription.InDefinedShape advice, boolean exit) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static interface ArgumentHandler {
&nbsp;        int THIS_REFERENCE = 0;
&nbsp;
&nbsp;        int argument(int i);
&nbsp;
&nbsp;        int exit();
&nbsp;
&nbsp;        int enter();
&nbsp;
&nbsp;        int named(java.lang.String s);
&nbsp;
&nbsp;        int returned();
&nbsp;
&nbsp;        int thrown();
&nbsp;
&nbsp;        static abstract enum Factory {
&nbsp;            SIMPLE, COPYING;
&nbsp;
&nbsp;            private Factory() { /* compiled code */ }
&nbsp;
&nbsp;            protected abstract net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod resolve(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.description.type.TypeDefinition typeDefinition1, java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; sortedMap);
&nbsp;        }
&nbsp;
&nbsp;        static interface ForAdvice extends net.bytebuddy.asm.Advice.ArgumentHandler {
&nbsp;            int mapped(int i);
&nbsp;
&nbsp;            static abstract class Default implements net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice {
<b class="fc">&nbsp;                protected final net.bytebuddy.description.method.MethodDescription instrumentedMethod;</b>
<b class="fc">&nbsp;                protected final net.bytebuddy.description.method.MethodDescription adviceMethod;</b>
<b class="fc">&nbsp;                protected final net.bytebuddy.description.type.TypeDefinition exitType;</b>
<b class="fc">&nbsp;                protected final java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes;</b>
&nbsp;
&nbsp;                protected Default(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.description.method.MethodDescription adviceMethod, net.bytebuddy.description.type.TypeDefinition exitType, java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes) { /* compiled code */ }
&nbsp;
&nbsp;                public int argument(int offset) { /* compiled code */ }
&nbsp;
&nbsp;                public int exit() { /* compiled code */ }
&nbsp;
&nbsp;                public int named(java.lang.String name) { /* compiled code */ }
&nbsp;
&nbsp;                public int enter() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ForMethodExit extends net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice.Default {
<b class="fc">&nbsp;                    private final net.bytebuddy.description.type.TypeDefinition enterType;</b>
<b class="fc">&nbsp;                    private final net.bytebuddy.implementation.bytecode.StackSize throwableSize;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    protected ForMethodExit(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.description.method.MethodDescription adviceMethod, net.bytebuddy.description.type.TypeDefinition exitType, java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, net.bytebuddy.description.type.TypeDefinition enterType, net.bytebuddy.implementation.bytecode.StackSize throwableSize) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public int returned() { /* compiled code */ }</b>
&nbsp;
&nbsp;                    public int thrown() { /* compiled code */ }
&nbsp;
&nbsp;                    public int mapped(int offset) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
<b class="nc">&nbsp;                protected static class ForMethodEnter extends net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice.Default {</b>
&nbsp;                    protected ForMethodEnter(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.description.method.MethodDescription adviceMethod, net.bytebuddy.description.type.TypeDefinition exitType, java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes) { /* compiled code */ }
&nbsp;
&nbsp;                    public int returned() { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                    public int thrown() { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public int mapped(int offset) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                    public int hashCode() { /* compiled code */ }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        static interface ForInstrumentedMethod extends net.bytebuddy.asm.Advice.ArgumentHandler {</b>
&nbsp;            int prepare(net.bytebuddy.jar.asm.MethodVisitor methodVisitor);
&nbsp;
<b class="fc">&nbsp;            net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice bindEnter(net.bytebuddy.description.method.MethodDescription methodDescription);</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription methodDescription, boolean b);</b>
<b class="nc">&nbsp;</b>
&nbsp;            boolean isCopyingArguments();
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            java.util.List&lt;net.bytebuddy.description.type.TypeDescription&gt; getNamedTypes();</b>
&nbsp;
<b class="fc">&nbsp;            static abstract class Default implements net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod {</b>
<b class="fc">&nbsp;                protected final net.bytebuddy.description.method.MethodDescription instrumentedMethod;</b>
<b class="fc">&nbsp;                protected final net.bytebuddy.description.type.TypeDefinition exitType;</b>
&nbsp;                protected final java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes;
<b class="nc">&nbsp;                protected final net.bytebuddy.description.type.TypeDefinition enterType;</b>
&nbsp;
<b class="nc">&nbsp;                protected Default(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.description.type.TypeDefinition exitType, java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, net.bytebuddy.description.type.TypeDefinition enterType) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public int exit() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public int named(java.lang.String name) { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                public int enter() { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                public int returned() { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                public int thrown() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice bindEnter(net.bytebuddy.description.method.MethodDescription adviceMethod) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public net.bytebuddy.asm.Advice.ArgumentHandler.ForAdvice bindExit(net.bytebuddy.description.method.MethodDescription adviceMethod, boolean skipThrowable) { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;                public java.util.List&lt;net.bytebuddy.description.type.TypeDescription&gt; getNamedTypes() { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
<b class="nc">&nbsp;                protected static class Copying extends net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod.Default {</b>
&nbsp;                    protected Copying(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.description.type.TypeDefinition exitType, java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, net.bytebuddy.description.type.TypeDefinition enterType) { /* compiled code */ }
&nbsp;
&nbsp;                    public int argument(int offset) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean isCopyingArguments() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                    public int prepare(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }</b>
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Simple extends net.bytebuddy.asm.Advice.ArgumentHandler.ForInstrumentedMethod.Default {
&nbsp;                    protected Simple(net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.description.type.TypeDefinition exitType, java.util.SortedMap&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes, net.bytebuddy.description.type.TypeDefinition enterType) { /* compiled code */ }
&nbsp;
&nbsp;                    public int argument(int offset) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean isCopyingArguments() { /* compiled code */ }
&nbsp;
&nbsp;                    public int prepare(net.bytebuddy.jar.asm.MethodVisitor methodVisitor) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static interface OffsetMapping {
&nbsp;        net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort);
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForSerializedValue implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
<b class="fc">&nbsp;            private final net.bytebuddy.description.type.TypeDescription typeDescription;</b>
<b class="fc">&nbsp;            private final net.bytebuddy.implementation.bytecode.StackManipulation deserialization;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public ForSerializedValue(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.implementation.bytecode.StackManipulation deserialization) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;            public static class Factory &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {
&nbsp;                private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;                private final net.bytebuddy.description.type.TypeDescription typeDescription;
&nbsp;                private final net.bytebuddy.implementation.bytecode.StackManipulation deserialization;
&nbsp;
&nbsp;                protected Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.implementation.bytecode.StackManipulation deserialization) { /* compiled code */ }
&nbsp;
&nbsp;                public static &lt;S extends java.lang.annotation.Annotation, U extends java.io.Serializable&gt; net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;S&gt; of(java.lang.Class&lt;S&gt; annotationType, U target, java.lang.Class&lt;? super U&gt; targetType) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="fc">&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;                public int hashCode() { /* compiled code */ }</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForStackManipulation implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation;
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic typeDescription;
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic targetType;
&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
<b class="fc">&nbsp;</b>
&nbsp;            public ForStackManipulation(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.description.type.TypeDescription.Generic typeDescription, net.bytebuddy.description.type.TypeDescription.Generic targetType, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfDynamicInvocation &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {
&nbsp;                private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;                private final net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;                private final java.util.List&lt;? extends net.bytebuddy.utility.JavaConstant&gt; arguments;
&nbsp;
<b class="nc">&nbsp;                public OfDynamicInvocation(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.method.MethodDescription.InDefinedShape bootstrapMethod, java.util.List&lt;? extends net.bytebuddy.utility.JavaConstant&gt; arguments) { /* compiled code */ }</b>
&nbsp;
&nbsp;                public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            public static class OfAnnotationProperty &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {</b>
&nbsp;                private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;                private final net.bytebuddy.description.method.MethodDescription.InDefinedShape property;
<b class="fc">&nbsp;</b>
&nbsp;                protected OfAnnotationProperty(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.method.MethodDescription.InDefinedShape property) { /* compiled code */ }
&nbsp;
&nbsp;                public static &lt;S extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;S&gt; of(java.lang.Class&lt;S&gt; annotationType, java.lang.String property) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }</b>
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;            public static class OfDefaultValue &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {</b>
&nbsp;                private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                public OfDefaultValue(java.lang.Class&lt;T&gt; annotationType) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }</b>
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;            public static class Factory &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {</b>
&nbsp;                private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;                private final net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation;
&nbsp;                private final net.bytebuddy.description.type.TypeDescription.Generic typeDescription;
&nbsp;
<b class="nc">&nbsp;                public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.type.TypeDescription typeDescription) { /* compiled code */ }</b>
&nbsp;
&nbsp;                public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.enumeration.EnumerationDescription enumerationDescription) { /* compiled code */ }
&nbsp;
&nbsp;                public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.utility.ConstantValue constant) { /* compiled code */ }
&nbsp;
&nbsp;                public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation, net.bytebuddy.description.type.TypeDescription.Generic typeDescription) { /* compiled code */ }
&nbsp;
<b class="fc">&nbsp;                public static &lt;S extends java.lang.annotation.Annotation&gt; net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;S&gt; of(java.lang.Class&lt;S&gt; annotationType, @net.bytebuddy.utility.nullability.MaybeNull java.lang.Object value) { /* compiled code */ }</b>
&nbsp;
&nbsp;                public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                public int hashCode() { /* compiled code */ }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForThrowable implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
<b class="fc">&nbsp;            private final boolean readOnly;</b>
&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
<b class="nc">&nbsp;            protected ForThrowable(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Thrown&gt; annotation) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public ForThrowable(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Thrown&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape THROWN_READ_ONLY;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape THROWN_TYPING;
&nbsp;
&nbsp;                private Factory() { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;                @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming annotation for exit advice.&quot;)</b>
&nbsp;                protected static net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;?&gt; of(net.bytebuddy.description.method.MethodDescription.InDefinedShape adviceMethod) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.Thrown&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Thrown&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForReturnValue implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForReturnValue(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Return&gt; annotation) { /* compiled code */ }
&nbsp;
&nbsp;            public ForReturnValue(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Return&gt; {
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape RETURN_READ_ONLY;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape RETURN_TYPING;
&nbsp;
&nbsp;                private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.Return&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Return&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForLocalValue implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic localType;
&nbsp;            private final java.lang.String name;
&nbsp;
&nbsp;            public ForLocalValue(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.type.TypeDescription.Generic localType, java.lang.String name) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
<b class="nc">&nbsp;            protected static class Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Local&gt; {</b>
<b class="nc">&nbsp;                protected static final net.bytebuddy.description.method.MethodDescription.InDefinedShape LOCAL_VALUE;</b>
<b class="nc">&nbsp;                private final java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes;</b>
&nbsp;
&nbsp;                protected Factory(java.util.Map&lt;java.lang.String,net.bytebuddy.description.type.TypeDefinition&gt; namedTypes) { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.Local&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Local&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForExitValue implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic exitType;
&nbsp;            private final boolean readOnly;
&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForExitValue(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.type.TypeDescription.Generic exitType, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Exit&gt; annotation) { /* compiled code */ }
&nbsp;
&nbsp;            public ForExitValue(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.type.TypeDescription.Generic exitType, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Exit&gt; {
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape EXIT_READ_ONLY;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape EXIT_TYPING;
&nbsp;                private final net.bytebuddy.description.type.TypeDefinition exitType;
&nbsp;
&nbsp;                protected Factory(net.bytebuddy.description.type.TypeDefinition exitType) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;                protected static net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Exit&gt; of(net.bytebuddy.description.type.TypeDefinition typeDefinition) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.Exit&gt; getAnnotationType() { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Exit&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                public int hashCode() { /* compiled code */ }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;        static class ForEnterValue implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
<b class="nc">&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic enterType;</b>
<b class="nc">&nbsp;            private final boolean readOnly;</b>
<b class="nc">&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            protected ForEnterValue(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.type.TypeDescription.Generic enterType, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Enter&gt; annotation) { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;            public ForEnterValue(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.type.TypeDescription.Generic enterType, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Enter&gt; {
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ENTER_READ_ONLY;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ENTER_TYPING;
&nbsp;                private final net.bytebuddy.description.type.TypeDefinition enterType;
&nbsp;
&nbsp;                protected Factory(net.bytebuddy.description.type.TypeDefinition enterType) { /* compiled code */ }
&nbsp;
&nbsp;                protected static net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Enter&gt; of(net.bytebuddy.description.type.TypeDefinition typeDefinition) { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.Enter&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Enter&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static enum ForStubValue implements net.bytebuddy.asm.Advice.OffsetMapping, net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.StubValue&gt; {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForStubValue() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            public java.lang.Class&lt;net.bytebuddy.asm.Advice.StubValue&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.StubValue&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForUnusedValue implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDefinition target;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public ForUnusedValue(net.bytebuddy.description.type.TypeDefinition target) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public int hashCode() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Unused&gt; {</b>
<b class="nc">&nbsp;                INSTANCE;</b>
<b class="nc">&nbsp;</b>
&nbsp;                private Factory() { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.Unused&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Unused&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static abstract enum ForSelfCallHandle implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            BOUND, UNBOUND;
&nbsp;
&nbsp;            private ForSelfCallHandle() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            protected abstract net.bytebuddy.implementation.bytecode.StackManipulation decorate(net.bytebuddy.description.method.MethodDescription methodDescription, net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation);
&nbsp;
&nbsp;            protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.SelfCallHandle&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape SELF_CALL_HANDLE_BOUND;
&nbsp;
&nbsp;                private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.SelfCallHandle&gt; getAnnotationType() { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.SelfCallHandle&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForOrigin implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private static final char DELIMITER = &#39;#&#39;;
&nbsp;            private static final char ESCAPE = &#39;\\&#39;;
&nbsp;            private final java.util.List&lt;net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer&gt; renderers;
&nbsp;
&nbsp;            public ForOrigin(java.util.List&lt;net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer&gt; renderers) { /* compiled code */ }
&nbsp;
&nbsp;            public static net.bytebuddy.asm.Advice.OffsetMapping parse(java.lang.String pattern) { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;            protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Origin&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ORIGIN_VALUE;
&nbsp;
&nbsp;                private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.Origin&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Origin&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            public static interface Renderer {
&nbsp;                java.lang.String apply(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription);
&nbsp;
&nbsp;                static enum ForPropertyName implements net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;p&#39;;
&nbsp;
&nbsp;                    private ForPropertyName() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.String apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;                }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
<b class="nc">&nbsp;                static class ForConstantValue implements net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer {</b>
<b class="nc">&nbsp;                    private final java.lang.String value;</b>
&nbsp;
&nbsp;                    public ForConstantValue(java.lang.String value) { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.String apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                static enum ForStringRepresentation implements net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private ForStringRepresentation() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.String apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;                }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                static enum ForReturnTypeName implements net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer {</b>
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;r&#39;;
&nbsp;
<b class="nc">&nbsp;                    private ForReturnTypeName() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public java.lang.String apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                static enum ForJavaSignature implements net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;s&#39;;
&nbsp;
<b class="fc">&nbsp;                    private ForJavaSignature() { /* compiled code */ }</b>
&nbsp;
&nbsp;                    public java.lang.String apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                static enum ForDescriptor implements net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer {</b>
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;d&#39;;
&nbsp;
&nbsp;                    private ForDescriptor() { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                    public java.lang.String apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                static enum ForTypeName implements net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;t&#39;;
&nbsp;
<b class="nc">&nbsp;                    private ForTypeName() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public java.lang.String apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                static enum ForMethodName implements net.bytebuddy.asm.Advice.OffsetMapping.ForOrigin.Renderer {</b>
<b class="nc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;m&#39;;
&nbsp;
&nbsp;                    private ForMethodName() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.String apply(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static abstract class ForFieldHandle implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Access access;
&nbsp;
&nbsp;            protected ForFieldHandle(net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Access access) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            protected abstract net.bytebuddy.description.field.FieldDescription resolve(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription);
&nbsp;
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Resolved extends net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle {
&nbsp;                private final net.bytebuddy.description.field.FieldDescription fieldDescription;
&nbsp;
&nbsp;                public Resolved(net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Access access, net.bytebuddy.description.field.FieldDescription fieldDescription) { /* compiled code */ }
&nbsp;
&nbsp;                @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                protected net.bytebuddy.description.field.FieldDescription resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Factory &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {
&nbsp;                    private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;                    private final net.bytebuddy.description.field.FieldDescription fieldDescription;
&nbsp;                    private final net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Access access;
&nbsp;
&nbsp;                    public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.field.FieldDescription fieldDescription, net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Access access) { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static abstract class Unresolved extends net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle {
&nbsp;                protected static final java.lang.String BEAN_PROPERTY = &quot;&quot;;
&nbsp;                private final java.lang.String name;
&nbsp;
&nbsp;                public Unresolved(net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Access access, java.lang.String name) { /* compiled code */ }
&nbsp;
&nbsp;                protected net.bytebuddy.description.field.FieldDescription resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;
&nbsp;                protected abstract net.bytebuddy.dynamic.scaffold.FieldLocator fieldLocator(net.bytebuddy.description.type.TypeDescription typeDescription);
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                protected static enum WriterFactory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.FieldSetterHandle&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_VALUE;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_DECLARING_TYPE;
&nbsp;
&nbsp;                    private WriterFactory() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.FieldSetterHandle&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.FieldSetterHandle&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                protected static enum ReaderFactory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.FieldGetterHandle&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_VALUE;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_DECLARING_TYPE;
&nbsp;
&nbsp;                    private ReaderFactory() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.FieldGetterHandle&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.FieldGetterHandle&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithExplicitType extends net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Unresolved {
&nbsp;                    private final net.bytebuddy.description.type.TypeDescription declaringType;
&nbsp;
&nbsp;                    public WithExplicitType(net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Access access, java.lang.String name, net.bytebuddy.description.type.TypeDescription declaringType) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.FieldLocator fieldLocator(net.bytebuddy.description.type.TypeDescription instrumentedType) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                public static class WithImplicitType extends net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Unresolved {
&nbsp;                    public WithImplicitType(net.bytebuddy.asm.Advice.OffsetMapping.ForFieldHandle.Access access, java.lang.String name) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.FieldLocator fieldLocator(net.bytebuddy.description.type.TypeDescription instrumentedType) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static abstract enum Access {
&nbsp;                GETTER, SETTER;
&nbsp;
&nbsp;                private Access() { /* compiled code */ }
&nbsp;
&nbsp;                protected abstract net.bytebuddy.utility.JavaConstant.MethodHandle resolve(net.bytebuddy.description.field.FieldDescription.InDefinedShape inDefinedShape);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static abstract class ForField implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape FIELD_VALUE;
<b class="nc">&nbsp;            private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape FIELD_DECLARING_TYPE;</b>
<b class="nc">&nbsp;            private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape FIELD_READ_ONLY;</b>
&nbsp;            private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape FIELD_TYPING;
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForField(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            protected abstract net.bytebuddy.description.field.FieldDescription resolve(net.bytebuddy.description.type.TypeDescription typeDescription, net.bytebuddy.description.method.MethodDescription methodDescription);
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public int hashCode() { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance</b>
<b class="nc">&nbsp;            public static class Resolved extends net.bytebuddy.asm.Advice.OffsetMapping.ForField {</b>
<b class="nc">&nbsp;                private final net.bytebuddy.description.field.FieldDescription fieldDescription;</b>
&nbsp;
<b class="nc">&nbsp;                public Resolved(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, net.bytebuddy.description.field.FieldDescription fieldDescription) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming declaring type for type member.&quot;)</b>
<b class="nc">&nbsp;                protected net.bytebuddy.description.field.FieldDescription resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Factory &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {
&nbsp;                    private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;                    private final net.bytebuddy.description.field.FieldDescription fieldDescription;
&nbsp;                    private final boolean readOnly;
&nbsp;                    private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
&nbsp;                    public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.field.FieldDescription fieldDescription) { /* compiled code */ }
&nbsp;
&nbsp;                    public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.field.FieldDescription fieldDescription, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static abstract class Unresolved extends net.bytebuddy.asm.Advice.OffsetMapping.ForField {
&nbsp;                protected static final java.lang.String BEAN_PROPERTY = &quot;&quot;;
&nbsp;                private final java.lang.String name;
&nbsp;
&nbsp;                protected Unresolved(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, java.lang.String name) { /* compiled code */ }
&nbsp;
&nbsp;                protected net.bytebuddy.description.field.FieldDescription resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;
&nbsp;                protected abstract net.bytebuddy.dynamic.scaffold.FieldLocator fieldLocator(net.bytebuddy.description.type.TypeDescription typeDescription);
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.FieldValue&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.FieldValue&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.FieldValue&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithExplicitType extends net.bytebuddy.asm.Advice.OffsetMapping.ForField.Unresolved {
&nbsp;                    private final net.bytebuddy.description.type.TypeDescription declaringType;
&nbsp;
&nbsp;                    protected WithExplicitType(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.FieldValue&gt; annotation, net.bytebuddy.description.type.TypeDescription declaringType) { /* compiled code */ }
&nbsp;
&nbsp;                    public WithExplicitType(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, java.lang.String name, net.bytebuddy.description.type.TypeDescription declaringType) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.FieldLocator fieldLocator(net.bytebuddy.description.type.TypeDescription instrumentedType) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                public static class WithImplicitType extends net.bytebuddy.asm.Advice.OffsetMapping.ForField.Unresolved {
&nbsp;                    protected WithImplicitType(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.FieldValue&gt; annotation) { /* compiled code */ }
&nbsp;
&nbsp;                    public WithImplicitType(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, java.lang.String name) { /* compiled code */ }
&nbsp;
&nbsp;                    protected net.bytebuddy.dynamic.scaffold.FieldLocator fieldLocator(net.bytebuddy.description.type.TypeDescription instrumentedType) { /* compiled code */ }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        static abstract enum ForInstrumentedMethod implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            METHOD, CONSTRUCTOR, EXECUTABLE, METHOD_HANDLE, METHOD_TYPE;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            private ForInstrumentedMethod() { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            protected abstract boolean isRepresentable(net.bytebuddy.description.method.MethodDescription methodDescription);</b>
&nbsp;
<b class="nc">&nbsp;            protected abstract net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.method.MethodDescription.InDefinedShape inDefinedShape);</b>
&nbsp;        }
&nbsp;
&nbsp;        static enum ForInstrumentedType implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForInstrumentedType() { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForAllArguments implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;            private final boolean includeSelf;
&nbsp;            private final boolean nullIfEmpty;
&nbsp;
&nbsp;            protected ForAllArguments(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.AllArguments&gt; annotation) { /* compiled code */ }
&nbsp;
&nbsp;            public ForAllArguments(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, boolean includeSelf, boolean nullIfEmpty) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
<b class="nc">&nbsp;</b>
&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
<b class="nc">&nbsp;            protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.AllArguments&gt; {</b>
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ALL_ARGUMENTS_READ_ONLY;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ALL_ARGUMENTS_TYPING;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ALL_ARGUMENTS_INCLUDE_SELF;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ALL_ARGUMENTS_NULL_IF_EMPTY;
&nbsp;
&nbsp;                private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.AllArguments&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;}, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.AllArguments&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static class ForThisReference implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            private final net.bytebuddy.description.type.TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;            private final boolean optional;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            protected ForThisReference(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.This&gt; annotation) { /* compiled code */ }</b>
&nbsp;
&nbsp;            public ForThisReference(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, boolean optional) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
&nbsp;
<b class="nc">&nbsp;            public int hashCode() { /* compiled code */ }</b>
&nbsp;
&nbsp;            protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.This&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape THIS_READ_ONLY;
&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape THIS_TYPING;
<b class="fc">&nbsp;                private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape THIS_OPTIONAL;</b>
&nbsp;
&nbsp;                private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;net.bytebuddy.asm.Advice.This&gt; getAnnotationType() { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.This&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;        static abstract class ForArgument implements net.bytebuddy.asm.Advice.OffsetMapping {
&nbsp;            protected final net.bytebuddy.description.type.TypeDescription.Generic target;
&nbsp;            protected final boolean readOnly;
&nbsp;            private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForArgument(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;            public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }
&nbsp;
&nbsp;            protected abstract net.bytebuddy.description.method.ParameterDescription resolve(net.bytebuddy.description.method.MethodDescription methodDescription);
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Resolved extends net.bytebuddy.asm.Advice.OffsetMapping.ForArgument {
&nbsp;                private final net.bytebuddy.description.method.ParameterDescription parameterDescription;
&nbsp;
<b class="fc">&nbsp;                public Resolved(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, net.bytebuddy.description.method.ParameterDescription parameterDescription) { /* compiled code */ }</b>
&nbsp;
&nbsp;                protected net.bytebuddy.description.method.ParameterDescription resolve(net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;                public static class Factory &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {</b>
<b class="nc">&nbsp;                    private final java.lang.Class&lt;T&gt; annotationType;</b>
&nbsp;                    private final net.bytebuddy.description.method.ParameterDescription parameterDescription;
<b class="nc">&nbsp;                    private final boolean readOnly;</b>
<b class="nc">&nbsp;                    private final net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.method.ParameterDescription parameterDescription) { /* compiled code */ }</b>
&nbsp;
&nbsp;                    public Factory(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.description.method.ParameterDescription parameterDescription, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing) { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
<b class="fc">&nbsp;</b>
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Unresolved extends net.bytebuddy.asm.Advice.OffsetMapping.ForArgument {
&nbsp;                private final int index;
&nbsp;                private final boolean optional;
&nbsp;
&nbsp;                protected Unresolved(net.bytebuddy.description.type.TypeDescription.Generic target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Argument&gt; annotation) { /* compiled code */ }
&nbsp;
&nbsp;                protected Unresolved(net.bytebuddy.description.method.ParameterDescription parameterDescription) { /* compiled code */ }
&nbsp;
&nbsp;                public Unresolved(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, int index) { /* compiled code */ }
&nbsp;
&nbsp;                public Unresolved(net.bytebuddy.description.type.TypeDescription.Generic target, boolean readOnly, net.bytebuddy.implementation.bytecode.assign.Assigner.Typing typing, int index, boolean optional) { /* compiled code */ }
&nbsp;
&nbsp;                protected net.bytebuddy.description.method.ParameterDescription resolve(net.bytebuddy.description.method.MethodDescription instrumentedMethod) { /* compiled code */ }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping.Target resolve(net.bytebuddy.description.type.TypeDescription instrumentedType, net.bytebuddy.description.method.MethodDescription instrumentedMethod, net.bytebuddy.implementation.bytecode.assign.Assigner assigner, net.bytebuddy.asm.Advice.ArgumentHandler argumentHandler, net.bytebuddy.asm.Advice.OffsetMapping.Sort sort) { /* compiled code */ }</b>
<b class="fc">&nbsp;</b>
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                protected static enum Factory implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;net.bytebuddy.asm.Advice.Argument&gt; {
&nbsp;                    INSTANCE;
<b class="fc">&nbsp;</b>
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ARGUMENT_VALUE;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ARGUMENT_READ_ONLY;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ARGUMENT_TYPING;
&nbsp;                    private static final net.bytebuddy.description.method.MethodDescription.InDefinedShape ARGUMENT_OPTIONAL;
&nbsp;
&nbsp;                    private Factory() { /* compiled code */ }
&nbsp;
&nbsp;                    public java.lang.Class&lt;net.bytebuddy.asm.Advice.Argument&gt; getAnnotationType() { /* compiled code */ }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;net.bytebuddy.asm.Advice.Argument&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        static abstract enum Sort {</b>
&nbsp;            ENTER, EXIT;
&nbsp;
&nbsp;            private Sort() { /* compiled code */ }
&nbsp;
&nbsp;            public abstract boolean isPremature(net.bytebuddy.description.method.MethodDescription methodDescription);
&nbsp;        }
&nbsp;
&nbsp;        static interface Factory &lt;T extends java.lang.annotation.Annotation&gt; {
&nbsp;            java.lang.Class&lt;T&gt; getAnnotationType();
&nbsp;
&nbsp;            net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape inDefinedShape, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; loadable, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType);
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Illegal &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {
&nbsp;                private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                public Illegal(java.lang.Class&lt;T&gt; annotationType) { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class Simple &lt;T extends java.lang.annotation.Annotation&gt; implements net.bytebuddy.asm.Advice.OffsetMapping.Factory&lt;T&gt; {
&nbsp;                private final java.lang.Class&lt;T&gt; annotationType;
&nbsp;                private final net.bytebuddy.asm.Advice.OffsetMapping offsetMapping;
&nbsp;
&nbsp;                public Simple(java.lang.Class&lt;T&gt; annotationType, net.bytebuddy.asm.Advice.OffsetMapping offsetMapping) { /* compiled code */ }
&nbsp;
&nbsp;                public java.lang.Class&lt;T&gt; getAnnotationType() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.asm.Advice.OffsetMapping make(net.bytebuddy.description.method.ParameterDescription.InDefinedShape target, net.bytebuddy.description.annotation.AnnotationDescription.Loadable&lt;T&gt; annotation, net.bytebuddy.asm.Advice.OffsetMapping.Factory.AdviceType adviceType) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;            }
&nbsp;
&nbsp;            static enum AdviceType {
&nbsp;                DELEGATION, INLINING;
&nbsp;
&nbsp;                private final boolean delegation;
&nbsp;
&nbsp;                private AdviceType(boolean delegation) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean isDelegation() { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        static interface Target {
&nbsp;            net.bytebuddy.implementation.bytecode.StackManipulation resolveRead();
&nbsp;
&nbsp;            net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite();
&nbsp;
&nbsp;            net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int i);
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static class ForStackManipulation implements net.bytebuddy.asm.Advice.OffsetMapping.Target {
&nbsp;                private final net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation;
&nbsp;
&nbsp;                public ForStackManipulation(net.bytebuddy.implementation.bytecode.StackManipulation stackManipulation) { /* compiled code */ }
&nbsp;
&nbsp;                public static net.bytebuddy.asm.Advice.OffsetMapping.Target of(net.bytebuddy.description.method.MethodDescription.InDefinedShape methodDescription) { /* compiled code */ }
&nbsp;
&nbsp;                public static net.bytebuddy.asm.Advice.OffsetMapping.Target of(net.bytebuddy.description.type.TypeDescription typeDescription) { /* compiled code */ }
&nbsp;
&nbsp;                public static net.bytebuddy.asm.Advice.OffsetMapping.Target of(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object value) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveRead() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Writable implements net.bytebuddy.asm.Advice.OffsetMapping.Target {
&nbsp;                    private final net.bytebuddy.implementation.bytecode.StackManipulation read;
&nbsp;                    private final net.bytebuddy.implementation.bytecode.StackManipulation write;
&nbsp;
&nbsp;                    public Writable(net.bytebuddy.implementation.bytecode.StackManipulation read, net.bytebuddy.implementation.bytecode.StackManipulation write) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveRead() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static abstract class ForField implements net.bytebuddy.asm.Advice.OffsetMapping.Target {
&nbsp;                protected final net.bytebuddy.description.field.FieldDescription fieldDescription;
&nbsp;                protected final net.bytebuddy.implementation.bytecode.StackManipulation readAssignment;
&nbsp;
&nbsp;                protected ForField(net.bytebuddy.description.field.FieldDescription fieldDescription, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveRead() { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ReadWrite extends net.bytebuddy.asm.Advice.OffsetMapping.Target.ForField {
&nbsp;                    private final net.bytebuddy.implementation.bytecode.StackManipulation writeAssignment;
&nbsp;
&nbsp;                    public ReadWrite(net.bytebuddy.description.field.FieldDescription fieldDescription) { /* compiled code */ }
&nbsp;
&nbsp;                    public ReadWrite(net.bytebuddy.description.field.FieldDescription fieldDescription, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment, net.bytebuddy.implementation.bytecode.StackManipulation writeAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WriteOnly implements net.bytebuddy.asm.Advice.OffsetMapping.Target {
&nbsp;                    private final net.bytebuddy.description.field.FieldDescription fieldDescription;
&nbsp;                    private final net.bytebuddy.implementation.bytecode.StackManipulation writeAssignment;
&nbsp;
&nbsp;                    protected WriteOnly(net.bytebuddy.description.field.FieldDescription fieldDescription, net.bytebuddy.implementation.bytecode.StackManipulation writeAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveRead() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadOnly extends net.bytebuddy.asm.Advice.OffsetMapping.Target.ForField {
&nbsp;                    public ReadOnly(net.bytebuddy.description.field.FieldDescription fieldDescription) { /* compiled code */ }
&nbsp;
&nbsp;                    public ReadOnly(net.bytebuddy.description.field.FieldDescription fieldDescription, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static abstract class ForArray implements net.bytebuddy.asm.Advice.OffsetMapping.Target {
&nbsp;                protected final net.bytebuddy.description.type.TypeDescription.Generic target;
&nbsp;                protected final java.util.List&lt;? extends net.bytebuddy.implementation.bytecode.StackManipulation&gt; valueReads;
&nbsp;
&nbsp;                protected ForArray(net.bytebuddy.description.type.TypeDescription.Generic target, java.util.List&lt;? extends net.bytebuddy.implementation.bytecode.StackManipulation&gt; valueReads) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveRead() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ReadWrite extends net.bytebuddy.asm.Advice.OffsetMapping.Target.ForArray {
&nbsp;                    private final java.util.List&lt;? extends net.bytebuddy.implementation.bytecode.StackManipulation&gt; valueWrites;
&nbsp;
&nbsp;                    public ReadWrite(net.bytebuddy.description.type.TypeDescription.Generic target, java.util.List&lt;? extends net.bytebuddy.implementation.bytecode.StackManipulation&gt; valueReads, java.util.List&lt;? extends net.bytebuddy.implementation.bytecode.StackManipulation&gt; valueWrites) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadOnly extends net.bytebuddy.asm.Advice.OffsetMapping.Target.ForArray {
&nbsp;                    public ReadOnly(net.bytebuddy.description.type.TypeDescription.Generic target, java.util.List&lt;? extends net.bytebuddy.implementation.bytecode.StackManipulation&gt; valueReads) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static abstract class ForVariable implements net.bytebuddy.asm.Advice.OffsetMapping.Target {
&nbsp;                protected final net.bytebuddy.description.type.TypeDefinition typeDefinition;
&nbsp;                protected final int offset;
&nbsp;                protected final net.bytebuddy.implementation.bytecode.StackManipulation readAssignment;
&nbsp;
&nbsp;                protected ForVariable(net.bytebuddy.description.type.TypeDefinition typeDefinition, int offset, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveRead() { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ReadWrite extends net.bytebuddy.asm.Advice.OffsetMapping.Target.ForVariable {
&nbsp;                    private final net.bytebuddy.implementation.bytecode.StackManipulation writeAssignment;
&nbsp;
&nbsp;                    public ReadWrite(net.bytebuddy.description.type.TypeDefinition typeDefinition, int offset) { /* compiled code */ }
&nbsp;
&nbsp;                    public ReadWrite(net.bytebuddy.description.type.TypeDefinition typeDefinition, int offset, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment, net.bytebuddy.implementation.bytecode.StackManipulation writeAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;
&nbsp;                    public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                    public int hashCode() { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadOnly extends net.bytebuddy.asm.Advice.OffsetMapping.Target.ForVariable {
&nbsp;                    public ReadOnly(net.bytebuddy.description.type.TypeDefinition typeDefinition, int offset) { /* compiled code */ }
&nbsp;
&nbsp;                    public ReadOnly(net.bytebuddy.description.type.TypeDefinition typeDefinition, int offset, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
&nbsp;            static abstract class ForDefaultValue implements net.bytebuddy.asm.Advice.OffsetMapping.Target {
&nbsp;                protected final net.bytebuddy.description.type.TypeDefinition typeDefinition;
&nbsp;                protected final net.bytebuddy.implementation.bytecode.StackManipulation readAssignment;
&nbsp;
&nbsp;                protected ForDefaultValue(net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveRead() { /* compiled code */ }
&nbsp;
&nbsp;                public boolean equals(@net.bytebuddy.utility.nullability.MaybeNull java.lang.Object o) { /* compiled code */ }
&nbsp;
&nbsp;                public int hashCode() { /* compiled code */ }
&nbsp;
&nbsp;                public static class ReadWrite extends net.bytebuddy.asm.Advice.OffsetMapping.Target.ForDefaultValue {
&nbsp;                    public ReadWrite(net.bytebuddy.description.type.TypeDefinition typeDefinition) { /* compiled code */ }
&nbsp;
&nbsp;                    public ReadWrite(net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadOnly extends net.bytebuddy.asm.Advice.OffsetMapping.Target.ForDefaultValue {
&nbsp;                    public ReadOnly(net.bytebuddy.description.type.TypeDefinition typeDefinition) { /* compiled code */ }
&nbsp;
&nbsp;                    public ReadOnly(net.bytebuddy.description.type.TypeDefinition typeDefinition, net.bytebuddy.implementation.bytecode.StackManipulation readAssignment) { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                    public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            static abstract class AbstractReadOnlyAdapter implements net.bytebuddy.asm.Advice.OffsetMapping.Target {
&nbsp;                public AbstractReadOnlyAdapter() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveWrite() { /* compiled code */ }
&nbsp;
&nbsp;                public net.bytebuddy.implementation.bytecode.StackManipulation resolveIncrement(int value) { /* compiled code */ }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-10-10 12:11</div>
</div>
</body>
</html>
